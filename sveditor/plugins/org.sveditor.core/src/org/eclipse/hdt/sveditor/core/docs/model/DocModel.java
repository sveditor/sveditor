/****************************************************************************
 * Copyright (c) 2008-2014 Matthew Ballance and others.
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License 2.0 which is available at
 * https://www.eclipse.org/legal/epl-2.0/.
 *
 * SPDX-License-Identifier: EPL-2.0
 *
 *
 * Contributors:
 *     Armond Paiva - initial implementation
 ****************************************************************************/

package org.eclipse.hdt.sveditor.core.docs.model;

import java.io.IOException;
import java.io.Writer;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.eclipse.hdt.sveditor.core.docs.DocTopicManager;
import org.eclipse.hdt.sveditor.core.docs.IDocTopicManager;

/**
 * Model representation of the documentation set.
 * Generated by a DocModelFactory.
 * <p><p>
 * The model is a set of DocFiles, one for each source file, each of
 * which contains a set of DocTopics. Each DocTopic may also have
 * a set of child DocTopics when the DocTopic represents a scope
 * item such as a class, module, or interface.
 * <p>
 * @see DocModelFactory
 */
public class DocModel {
	
	/**
	 * Mapping of each DocFile by path. Path
	 * is that of the of the associated source file in
	 * the SVDBIndex.
	 * @see DocFile
	 */
	private Map<String, DocFile> docFiles ;
	
	/**
	 * Manager for all the known symbols
	 * @see SymbolTable
	 */
	private SymbolTable fSymbolTable ;
	
	/**
	 * One DocIndex per topic mapped by topic type name
	 * @see DocIndex
	 */
	private Map<String, DocIndex> indexMap ;
	
	/**
	 * Manger of all known topics and keywords
	 * @see IDocTopicManager
	 */
	private IDocTopicManager docTopicManager ;
	
	public DocModel() {
		docFiles = new HashMap<String, DocFile>() ;
		docTopicManager = new DocTopicManager() ;
		indexMap = new HashMap<String, DocIndex>() ;
		fSymbolTable = new SymbolTable() ;
	}
	
	/**
	 * Deletes all docFiles not markes as "Used"
	 * by a call to "markAsUsed".
	 */
	public void pruneUnsedFiles() {
		Iterator<String> it = docFiles.keySet().iterator() ;
		while(it.hasNext()) {
			String key = it.next() ;
		   if(!docFiles.get(key).fHasUsedSymbol){
			   it.remove() ;
		   }
		}
	}

	/**
	 * Adds a new docFile to the model
	 * 
	 * @param docFile
	 */
	public void addDocFile(DocFile docFile) {
		docFiles.put(docFile.getTitle(),docFile) ;
	}
	
	/**
	 * @param filePath
	 * @return
	 */
	public DocFile getDocFile(String filePath) {
		return docFiles.get(filePath) ;
	}
	
	public List<String> getDocFileKeysSorted() {
		List<String> sortedDocFileKeys = new ArrayList<String>(docFiles.keySet()) ;
		Collections.sort(sortedDocFileKeys) ;
		return sortedDocFileKeys ;
	}
	
	public Set<String> getFileSet() {
		return docFiles.keySet() ;
	}
	
	public Collection<DocFile> getDocFiles() {
		return new HashSet<DocFile>(docFiles.values()) ;
	}
	
	public SymbolTable getSymbolTable() {
		return fSymbolTable ;
	}

	public DocIndex getTopicIndexMap(String topic) {
		if(indexMap.containsKey(topic)) {
			return indexMap.get(topic) ;
		} else {
			return null ;
		}
	}
	
	public  DocIndex getCreateTopicIndexMap(String topic) {
		DocIndex index ;
		index = getTopicIndexMap(topic) ;
		if(index == null) {
			index = new DocIndex(topic) ;
			indexMap.put(topic, index) ;
		}
		return index ;
	}

	public IDocTopicManager getDocTopics() {
		return docTopicManager ;
	}
	
	/**
	 * Dumps content of model to a text
	 * file in a human readable format for debug and testing
	 * purposes
	 * <p><p>
	 * @param fileWriter Where to write the dump to
	 * @throws IOException 
	 */
	public void dumpToFile(Writer writer) throws IOException {
		fSymbolTable.dumpSymbolsToFile(writer) ;
		/*
		 * Generate a list of the DocFiles sorted by filename.
		 */
		List<DocFile> docFilesByName = new ArrayList<DocFile>(docFiles.values()) ;
		Collections.sort(docFilesByName, new Comparator<DocFile>() {
			public int compare(DocFile o1, DocFile o2) {
				return o1.getSrcFileName().compareToIgnoreCase(o2.getSrcFileName()) ;
			}
		}) ;
		
		/*
		 * Shallow dump of each DocFile
		 */
		writer.write(String.format(
				"+-------------------------------------------------------------------\n")) ;
		writer.write(String.format(
				"| DocFile set\n")) ;
		writer.write(String.format(
				"+-------------------------------------------------------------------\n")) ;
		for(DocFile docFile: docFilesByName) {
			writer.write(String.format(
					"| +-------------------------------------------------------------------\n")) ;
			writer.write(String.format(
					"| | DocFile: %s\n", docFile.getSrcFileName())) ;
			writer.write(String.format(
					"| +-------------------------------------------------------------------\n")) ;
			writer.write(String.format(
					"| | NumChildren(%d)\n", docFile.getChildren().size())) ;
			writer.write(String.format(
					"| | Summary(%s)\n", docFile.getSummary())) ;
			writer.write(String.format(
					"| +-------------------------------------------------------------------\n")) ;
		}
		writer.write(String.format(
				"+-------------------------------------------------------------------\n")) ;
		/*
		 *  Deep dive into Each DocFile
		 */
		for(DocFile docFile: docFilesByName) {
			String srcFileName = docFile.getSrcFileName() ;
			writer.write(String.format(
					"| +-------------------------------------------------------------------\n")) ;
			writer.write(String.format(
					"| | DocFile: %s\n", srcFileName)) ;
			writer.write(String.format(
					"| +-------------------------------------------------------------------\n")) ;
			for(DocTopic childTopic: docFile.getChildren()) {
				dumpTopic(writer, childTopic, String.format("| | [%s] ", srcFileName)) ;
			}
		}
		
	}

	private void dumpTopic(Writer writer, DocTopic topic, String preFix)
			throws IOException {
		writer.write(String.format(
				"%s+-------------------------------------------------------------------\n",
				preFix)) ;
		writer.write(String.format(
				"%s| TopicTitle: %s\n",
				preFix,
				topic.getTitle())) ;
		writer.write(String.format(
				"%s+-------------------------------------------------------------------\n",
				preFix)) ;
		writer.write(String.format(
				"%s| QualifiedName(%s)\n",
				preFix,
				topic.getQualifiedName())) ;
		writer.write(String.format(
				"%s| TopicType(%s)\n",
				preFix,
				topic.getTopic())) ;
		writer.write(String.format(
				"%s| Keyword(%s)\n",
				preFix,
				topic.getKeyword())) ;
		writer.write(String.format(
				"%s| NumChilderen(%d)\n",
				preFix,
				topic.getChildren().size())) ;
		writer.write(String.format(
				"%s| Summary(%s)\n",
				preFix,
				topic.getSummary())) ;
		writer.write(String.format(
				"%s| Body(%s)\n",
				preFix,
				topic.getBody())) ;
		if(topic.getChildren().size() != 0) {
			writer.write(String.format(
					"%s| +-------------------------------------------------------------------\n",
					preFix)) ;
			writer.write(String.format(
					"%s| | Children\n",
					preFix)) ;
			writer.write(String.format(
					"%s| +-------------------------------------------------------------------\n",
					preFix)) ;
			for(DocTopic childTopic: topic.getChildren()) {
				dumpTopic(writer, childTopic, String.format("%s| [%s] | ", 
						preFix,
						topic.getTitle())) ;
			}
		}
		writer.write(String.format(
				"%s+-------------------------------------------------------------------\n",
				preFix)) ;
	}

}
