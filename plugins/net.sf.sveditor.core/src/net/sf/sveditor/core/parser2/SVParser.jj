
options {
  LOOKAHEAD      = 5;
  STATIC = false ;
  /*
  DEBUG_PARSER = true;
  DEBUG_LOOKAHEAD = true;
  DEBUG_TOKEN_MANAGER = true;
   */
  USER_CHAR_STREAM = true;
}

PARSER_BEGIN(SVParser)

package net.sf.sveditor.core.parser2;

public class SVParser {

}


PARSER_END(SVParser)


/**
 * Rules for Whitespace 
 */
SKIP :
{
  " "
| "\t"
| "\n"
| "\r"
| "\f"
}

/* Comments removed for now */

/* Reserved words */
TOKEN :
{
  < ALIAS: 	"alias" >
| < ALWAYS: "always">
| < ALWAYS_COMB:	"always_comb">
| <	ALWAYS_FF: "always_ff">
| <	ALWAYS_LATCH: "always_latch">
| <	AND: "and">
| < ASSERT: "assert">
| <	ASSIGN: "assign">
| < ASSUME: "assume">
| < AUTOMATIC: 	"automatic">
| < BEFORE: 	"before">
| < BEGIN:		"begin">
| < BIND:		"bind">
| < BINS:		"bins">
| < BINSOF:		"binsof">
| < BIT:		"bit">
| < BREAK:		"break">
| < BUF:		"buf">
| < BUFIF0:		"bufif0">
| < BUFIF1:		"bufif1">
| < BYTE:		"byte">
| < CASE:		"case">
| < CASEX:		"casex">
| < CASEZ:		"casez">
| < CELL:		"cell">
| < CHANDLE:	"chandle">
| < CLASS:		"class">
| < CLOCKING:	"clocking">
| < CMOS:		"cmos">
| < CONFIG:		"config">
| < CONST:		"const">
| < CONSTRAINT:	"constraint">
| < CONTEXT:	"context">
| < CONTINUE:	"continue">
| < COVER:		"cover">
| < COVERGROUP:	"covergroup">
| < COVERPOINT: "coverpoint">
| < CROSS:		"cross">
| < DEASSIGN:	"deassign">
| < T_DEFAULT:	"default">
| < DEFPARAM:	"defparam">
| < DESIGN:		"design">
| < DISABLE:	"disable">
| < DIST:		"dist">
| < DO:			"do">
| < EDGE:		"edge">
| < ELSE:		"else">
| < END:		"end">
| < ENDCASE:	"endcase">
| < ENDCLASS:		"endclass">
| < ENDCLOCKING:	"endclocking">
| < ENDCONFIG:		"endconfig">
| < ENDFUNCTION:	"endfunction">
| < ENDGENERATE:	"endgenerate">
| < ENDGROUP:		"endgroup">
| < ENDINTERFACE:	"endinterface">
| < ENDMODULE:		"endmodule">
| < ENDPACKAGE:		"endpackage">
| < ENDPRIMITIVE:	"endprimitive">
| < ENDPROGRAM:		"endprogram">
| < ENDPROPERTY:	"endproperty">
| < ENDSPECIFY:		"endspecify">
| < ENDSEQUENCE:	"endsequence">
| < ENDTABLE:		"endtable">
| < ENDTASK:		"endtask">
| < ENUM:			"enum">
| < EVENT:			"event">
| < EXPECT:			"expect">
| < EXPORT:			"export">
| < EXTENDS:		"extends">
| < EXTERN:			"extern">
| < FINAL:			"final">
| < FIRST_MATCH:	"first_match">
| < FOR:			"for">
| < FORCE:			"force">
| < FOREACH:		"foreach">
| < FOREVER:		"forever">
| < FORK:			"fork">
| < FORKJOIN:		"forkjoin">
| < FUNCTION:		"function">
| < GENERATE:		"generate">
| < GENVAR:			"genvar">
| < HIGHZ0:			"highz0">
| < HIGHZ1:			"highz1">
| < IF:				"if">
| < IFF:			"iff">
| < IFNONE:			"ifnone">
| < IGNORE_BINS:	"ignore_bins">
| < ILLEGAL_BINS:	"illegal_bins">
| < IMPORT:			"import">
| < INCDIR:			"incdir">
| < INCLUDE:		"include">
| < INITIAL:		"initial">
| < INOUT:			"inout">
| < INPUT:			"input">
| < INSIDE:			"inside">
| < INSTANCE:		"instance">
| < INT:			"int">
| < INTEGER:		"integer">
| < INTERFACE:		"interface">
| < INTERSECT:		"intersect">
| < JOIN:			"join">
| < JOIN_ANY:		"join_any">
| < JOIN_NONE:		"join_none">
| < LARGE:			"large">
| < LIBLIST:		"liblist">
| < LIBRARY:		"library">
| < LOCAL:			"local">
| < LOCALPARAM:		"localparam">
| < LOGIC:			"logic">
| < LONGINT:		"longint">
| < MACROMODULE:	"macromodule">
| < MATCHES:		"matches">
| < MEDIUM:			"medium">
| < MODPORT:		"modport">
| < MODULE:			"module">
| < NAND:			"nand">
| < NEGEDGE:		"negedge">
| < NEW:			"new">
| < NMOS:			"nmos">
| < NOR:			"nor">
| < NOSHOWCANCELLED:	"noshowcancelled">
| < NOT:				"not">
| < NOTIF0:				"notif0">
| < NOTIF1:				"notif1">
| < NULL:				"null">
| < OPTION:             "option">
| < OR:					"or">
| < OUTPUT:				"output">
| < PACKAGE:			"package">
| < PACKED:				"packed">
| < PARAMETER:			"parameter">
| < PMOS:				"pmos">
| < POSEDGE:			"posedge">
| < PRIMITIVE:			"primitive">
| < PRIORITY:			"priority">
| < PROGRAM:			"program">
| < PROPERTY:			"property">
| < PROTECTED:			"protected">
| < PULL0:				"pull0">
| < PULL1:				"pull1">
| < PULLDOWN:			"pulldown">
| < PULLUP:				"pullup">
| < PULSESTYLE_ONEVENT:	"pulsestyle_onevent">
| < PULSESTYLE_ONDETECT:	"pulsestyle_ondetect">
| < PURE:					"pure">
| < RAND:					"rand">
| < RANDC:					"randc">
| < RANDCASE:				"randcase">
| < RANDSEQUENCE:			"randsequence">
| < RCMOS:					"rcmos">
| < REAL:					"real">
| < REALTIME:				"realtime">
| < REF:					"ref">
| < REG:					"reg">
| < RELEASE:				"release">
| < REPEAT:					"repeat">
| < RETURN:					"return">
| < RNMOS:					"rnmos">
| < RPMOS:					"rpmos">
| < RTRAN:					"rtran">
| < RTRANIF0:				"rtranif0">
| < RTRANIF1:				"rtranif1">
| < SCALARED:				"scalared">
| < SEQUENCE:				"sequence">
| < SHORTINT:				"shortint">
| < SHORTREAL:				"shortreal">
| < SHOWCANCELLED:			"showcancelled">
| < SIGNED:					"signed">
| < SMALL:					"small">
| < SOLVE:					"solve">
| < SPECIFY:				"specify">
| < SPECPARAM:				"specparam">
| < STATIC:					"static">
| < STRING:					"string">
| < STRONG0:				"strong0">
| < STRONG1:				"strong1">
| < STRUCT:					"struct">
| < SUPER:					"super">
| < SUPPLY0:				"supply0">
| < SUPPLY1:				"supply1">
| < TABLE:					"table">
| < TAGGED:					"tagged">
| < TASK:					"task">
| < THIS:					"this">
| < THROUGHOUT:				"throughout">
| < TIME:					"time">
| < TIMEPRECISION:			"timeprecision">
| < TIMEUNIT:				"timeunit">
| < TRAN:					"tran">
| < TRANIF0:				"tranif0">
| < TRANIF1:				"tranif1">
| < TRI:					"tri">
| < TRI0:					"tri0">
| < TRI1:					"tri1">
| < TRIAND:					"triand">
| < TRIOR:					"trior">
| < TRIREG:					"trireg">
| < TYPE:					"type">
| < TYPE_OPTION:            "type_option">
| < TYPEDEF:				"typedef">
| < UNION:					"union">
| < UNIQUE:					"unique">
| < UNSIGNED:				"unsigned">
| < USE:					"use">
| < UWIRE:					"uwire">
| < VAR:					"var">
| < VECTORED:				"vectored">
| < VIRTUAL:				"virtual">
| < VOID:					"void">
| < WAIT:					"wait">
| < WAIT_ORDER:				"wait_order">
| < WAND:					"wand">
| < WEAK0:					"weak0">
| < WEAK1:					"weak1">
| < WHILE:					"while">
| < WILDCARD:				"wildcard">
| < WIRE:					"wire">
| < WITH:					"with">
| < WITHIN:					"within">
| < WOR:					"wor">
| < XNOR:					"xnor">
| < XOR:					"xor">
| < PATHPULSE:              "PATHPULSE$">
| < RANDOMIZE:              "randomize">
| < SEMICOLON:              ";">
| < TF_IDENT:               ("$" ["a"-"z","A"-"Z","0"-"9","_","$"](["a"-"z","A"-"Z","0"-"9","_","$"])*)>
| < S_IDENT:                (["a"-"z","A"-"Z","_"] (["a"-"z","A"-"Z","0"-"9","_","$"])*)>
| < C_IDENT:                (["a"-"z", "A"-"Z", "_"] (["a"-"z", "A"-"Z", "0"-"9", "_"])*)>
| < ATTR_START:             "(*">
| < ATTR_END:               "*)">
| <ESCAPE:                  "\\">
| < NZ_DEC_DIGIT:           (["1"-"9"])>
| < DEC_DIGIT:              (["0"-"9"])>
| < HEX_DIGIT:              (["0"-"9","a"-"f","A"-"F"])>
| < OCT_DIGIT:              (["0"-"7"])>
}

/****************************************************************************
 * A.1.2 SystemVerilog source text
 ****************************************************************************/
void description() :
{
}
{
	(
	 module_declaration() 		|
/*	 udp_declaration()    		| TODO: */
	 interface_declaration() 	| 
	 program_declaration()		|
	 package_declaration()		|
	 (attribute_instance())* package_item()   |
	 (attribute_instance())* bind_directive() |
	 config_declaration()                    
	 )* 
	 <EOF>
}



void module_nonansi_header() :
{
	Token module_id = null;
}
{
	(attribute_instance())* module_keyword() [lifetime()] 
		module_id = module_identifier() 
		[ parameter_port_list() ] list_of_ports() <SEMICOLON>
	{
		System.out.println("non-ansi id: " + module_id.image);
	}
}

void module_ansi_header() :
{
	Token module_id = null;
}
{
  (attribute_instance())* module_keyword() [lifetime()] 
  	module_id = module_identifier()  
  	[ parameter_port_list() ]
	[ list_of_port_declarations() ] <SEMICOLON>
	
  {
  	System.out.println("module_id=" + module_id.image);
  }
}

void module_keyword() :
{
}
{
	<MODULE> | <MACROMODULE>
}

void module_declaration() :
{
}
{
	module_nonansi_header() [ timeunits_declaration() ] ( module_item() )*
	 <ENDMODULE> [ ":" module_identifier() ]
	| module_ansi_header() [ timeunits_declaration() ] (non_port_module_item())*
	<ENDMODULE> [ ":" module_identifier() ]
	| ( attribute_instance() )* module_keyword() [ lifetime() ] module_identifier() "(" ".*" ")" <SEMICOLON>
	[ timeunits_declaration() ] (module_item())* <ENDMODULE> [ ":" module_identifier() ]
	| <EXTERN> module_nonansi_header()
	| <EXTERN> module_ansi_header()
}

void interface_nonansi_header() :
{
}
{
    (attribute_instance())* <INTERFACE> [lifetime()] interface_identifier()
		[parameter_port_list()] list_of_ports() <SEMICOLON>
}

		
void interface_ansi_header() :
{
}
{
	(attribute_instance())* <INTERFACE> [lifetime()] interface_identifier()
	[parameter_port_list()] [list_of_port_declarations()] <SEMICOLON>
}

void interface_declaration() :
{
}
{
  (
	interface_nonansi_header() [timeunits_declaration()] (interface_item())*
		<ENDINTERFACE> [ ":" interface_identifier() ]
	| interface_ansi_header() [timeunits_declaration()] (non_port_interface_item())*
		<ENDINTERFACE> [ ":" interface_identifier() ]
	| (attribute_instance())* <INTERFACE> interface_identifier() "(" ".*" ")" <SEMICOLON>
		[ timeunits_declaration() ] (interface_item())*
		<ENDINTERFACE> [ ":" interface_identifier() ]
	| <EXTERN> interface_nonansi_header()
	| <EXTERN> interface_ansi_header()
  )
}

void program_nonansi_header() :
{
}
{
    (attribute_instance())* <PROGRAM> [ lifetime() ] program_identifier()
		[parameter_port_list()] list_of_ports() <SEMICOLON>
}

void program_ansi_header() :
{
}
{
	(attribute_instance())* <PROGRAM> [lifetime()] program_identifier()
	[parameter_port_list()] [ list_of_port_declarations() ] <SEMICOLON>
}

void program_declaration() :
{
}
{
  (
	program_nonansi_header() [timeunits_declaration() ] (program_item())*
		<ENDPROGRAM> [ ":" program_identifier() ]
	| program_ansi_header() [ timeunits_declaration() ] (non_port_program_item())*
		<ENDPROGRAM> [ ":" program_identifier() ]
	| (attribute_instance())* <PROGRAM> program_identifier() "(" ".*" ")" <SEMICOLON>
		[ timeunits_declaration() ] (program_item())*
		<ENDPROGRAM> [ ":" program_identifier() ]
	| <EXTERN> program_nonansi_header()
	| <EXTERN> program_ansi_header()
  )
}

void class_declaration() :
{
}
{
	[ <VIRTUAL> ] <CLASS> [ lifetime() ] class_identifier() [ parameter_port_list() ]
	[ <EXTENDS> class_type() [ "(" list_of_arguments() ")" ] ] <SEMICOLON>
	(class_item())*
	<ENDCLASS> [ ":" class_identifier() ]
}

void package_declaration() :
{
}
{
	(attribute_instance())* <PACKAGE> package_identifier() <SEMICOLON>
		[timeunits_declaration()] ((attribute_instance())* package_item())*
	<ENDPACKAGE> [ ":" package_identifier() ]
}

void timeunits_declaration() :
{
}
{
  (
	<TIMEUNIT> time_literal() <SEMICOLON>
	| <TIMEPRECISION> time_literal() <SEMICOLON>
	| <TIMEUNIT> time_literal() <SEMICOLON>
		<TIMEPRECISION> time_literal() <SEMICOLON>
	| <TIMEPRECISION> time_literal() <SEMICOLON>
		<TIMEUNIT> time_literal() <SEMICOLON>
  )
}


/****************************************************************************
 * A.1.3 Module parameters and ports
 ****************************************************************************/
void parameter_port_list() :
{
}
{
  (
	"#" "("	list_of_param_assignments() ("," parameter_port_declaration())* ")"
	| "#" "(" parameter_port_declaration() ("," parameter_port_declaration())* ")"
	| "#" "(" ")"
  )
}

void parameter_port_declaration() :
{
}
{
  (
	parameter_declaration()
	| data_type() list_of_param_assignments()
	| <TYPE> list_of_type_assignments()
  )
}

void list_of_ports() :
{
}
{
	"(" port() ( "," port())* ")"
}

void list_of_port_declarations() :
{
}
{
	"(" [(attribute_instance())* ansi_port_declaration() ( "," (attribute_instance())* ansi_port_declaration())* ] ")"
}

void port_declaration() :
{
}
{
  (
	(attribute_instance())* inout_declaration()
	| (attribute_instance())* input_declaration()
	| (attribute_instance())* output_declaration()
	| (attribute_instance())* ref_declaration()
	| (attribute_instance())* interface_port_declaration()
  )
}

void port() :
{
}
{
	[ port_expression() ]
	| "." port_identifier() "(" [ port_expression() ] ")"
}

void port_expression() :
{
}
{
	port_reference()
	| "{" port_reference() ( "," port_reference())* "}"
}

void port_reference() :
{
}
{
	port_identifier() constant_select()
}

void port_direction() :
{
}
{
	<INPUT> | <OUTPUT> | <INOUT> | <REF>
}

void net_port_header() :
{
}
{
	[ port_direction() ] net_port_type()
}

void variable_port_header() :
{
}
{
	[ port_direction() ] variable_port_type()
}

void interface_port_header() :
{
}
{
  (
	interface_identifier() [ "." modport_identifier() ]
	| <INTERFACE> [ "." modport_identifier() ]
  )
}

void ansi_port_declaration() :
{
}
{
	// FIXME: net_port_header() can expand as ""
	// [ net_port_header() | interface_port_header() ] port_identifier() (unpacked_dimension())*
	[ interface_port_header() ] port_identifier() (unpacked_dimension())*
	| [ variable_port_header() ] port_identifier() (variable_dimension())* [ "=" constant_expression() ]
	
	// FIXME: net_port_header() can expand as ""
	// CHG: expression can expand to "", so remove []
	// | [ net_port_header() | variable_port_header() ] "." port_identifier() "(" [ expression() ] ")"
	| [ variable_port_header() ] "." port_identifier() "(" expression() ")"
}

/****************************************************************************
 * A.1.4 Module items
 ****************************************************************************/
void module_common_item() :
{
}
{
  (
	module_or_generate_item_declaration()
	| interface_instantiation()
	| program_instantiation()
	| concurrent_assertion_item()
	| bind_directive()
	| continuous_assign()
	| net_alias()
	| initial_construct()
	| final_construct()
	| always_construct()
	| loop_generate_construct()
	| conditional_generate_construct()
  )
}

void module_item() :
{
}
{
  (
	port_declaration() <SEMICOLON>
	| non_port_module_item()
  )
}

void module_or_generate_item() :
{
}
{
  (
	(attribute_instance())* parameter_override()
	| (attribute_instance())* gate_instantiation()
	| (attribute_instance())* udp_instantiation()
	| (attribute_instance())* module_instantiation()
	| (attribute_instance())* module_common_item()
  )
}

void module_or_generate_item_declaration() :
{
}
{
  (
	package_or_generate_item_declaration() 
	| genvar_declaration()
	| clocking_declaration()
	| <T_DEFAULT> <CLOCKING> clocking_identifier() <SEMICOLON>
  )
}

void non_port_module_item() :
{
}
{
  (
	generate_region()
	| module_or_generate_item()
	| specify_block()
	| (attribute_instance())* specparam_declaration()
	| program_declaration()
	| module_declaration()
	| interface_declaration()
	| timeunits_declaration()
  )
}

void parameter_override() :
{
}
{
	<DEFPARAM> list_of_defparam_assignments() <SEMICOLON>
}

void bind_directive() :
{
}
{
  (
	<BIND> bind_target_scope() [":" bind_target_instance_list()] bind_instantiation() <SEMICOLON>
	| <BIND> bind_target_instance() bind_instantiation() <SEMICOLON>
  )
}

void bind_target_scope() :
{
}
{
  (
	module_identifier()
	| interface_identifier()
  )
}

void bind_target_instance() :
{
}
{
	hierarchical_identifier() constant_bit_select()
}

void bind_target_instance_list() :
{
}
{
	bind_target_instance() ("," bind_target_instance())*
}

void bind_instantiation() :
{
}
{
	program_instantiation()
	| module_instantiation()
	| interface_instantiation()	
}

/****************************************************************************
 * A.1.5 Configuration source text
 ****************************************************************************/
void config_declaration() :
{
}
{
	<CONFIG> config_identifier() <SEMICOLON>
	design_statement()
	(config_rule_statement())*
	<ENDCONFIG> [ ":" config_identifier() ]
}

void design_statement() :
{
}
{
	<DESIGN> ( [ library_identifier() "." ] cell_identifier() )* <SEMICOLON>
}

void config_rule_statement() :
{
}
{
  (
	default_clause() liblist_clause() <SEMICOLON>
	| inst_clause() liblist_clause() <SEMICOLON>
	| inst_clause() use_clause() <SEMICOLON>
	| cell_clause() liblist_clause() <SEMICOLON>
	| cell_clause() use_clause() <SEMICOLON>
  )
}

void default_clause() :
{
}
{
	<T_DEFAULT>
}

void inst_clause() :
{
}
{
	<INSTANCE> inst_name()
}

void inst_name() :
{
}
{
	topmodule_identifier() ( "." instance_identifier() )*
}

void cell_clause() :
{
}
{
	<CELL> [ library_identifier() "." ] cell_identifier()
}

void liblist_clause() :
{
}
{
	<LIBLIST> (library_identifier())*
}

void use_clause() :
{
}
{
	<USE> [ library_identifier() "." ] cell_identifier() [ ":" <CONFIG> ]
}
	
/****************************************************************************
 * A.1.6 Interface items
 ****************************************************************************/

void interface_or_generate_item() :
{
}
{
  (
	(attribute_instance())* module_common_item()
	| (attribute_instance())* modport_declaration()
	| (attribute_instance())* extern_tf_declaration()
  )
}

void extern_tf_declaration() :
{
}
{
  (
	<EXTERN> method_prototype() <SEMICOLON>
	| <EXTERN> <FORKJOIN> task_prototype() <SEMICOLON>
  )
}

void interface_item() :
{
}
{
  (
	port_declaration() <SEMICOLON>
	| non_port_interface_item()
  )
}

void non_port_interface_item() :
{
}
{
  (
	generate_region()
	| interface_or_generate_item()
	| program_declaration()
	| interface_declaration()
	| timeunits_declaration()
  )
}

/****************************************************************************
 * A.1.7 Program items
 ****************************************************************************/
void program_item() :
{
}
{
  (
	port_declaration() <SEMICOLON>
	| non_port_program_item()
  )
}

void non_port_program_item() :
{
}
{
  (
	(attribute_instance())* continuous_assign()
	| (attribute_instance())* module_or_generate_item_declaration()
	| (attribute_instance())* initial_construct()
	| (attribute_instance())* final_construct()
	| (attribute_instance())* concurrent_assertion_item()
	| (attribute_instance())* timeunits_declaration()
	| program_generate_item()
  )
}

void program_generate_item() :
{
}
{
  (
	loop_generate_construct()
	| conditional_generate_construct()
	| generate_region()
  )
}

/****************************************************************************
 * A.1.8 Class items
 ****************************************************************************/
void class_item() :
{
}
{
  (
	(attribute_instance())* class_property()
	| (attribute_instance())* class_method()
	| (attribute_instance())* class_constraint()
	| (attribute_instance())* class_declaration()
	| (attribute_instance())* timeunits_declaration()
	| (attribute_instance())* covergroup_declaration()
	| <SEMICOLON>
  )
}

void class_property() :
{
}
{
  (
	(property_qualifier())* data_declaration()
	| <CONST> (class_item_qualifier())* data_type() const_identifier() [ "=" constant_expression() ] <SEMICOLON>
  )
}

void class_method() :
{
}
{
  (
	(method_qualifier())* task_declaration()
	| (method_qualifier())* function_declaration()
	| <EXTERN> (method_qualifier())* method_prototype() <SEMICOLON>
	| (method_qualifier())* class_constructor_declaration()
	| <EXTERN> (method_qualifier())* class_constructor_prototype()
  )
}

void class_constructor_prototype() :
{
}
{
    // CHG: tf_port_list() can expand to "", so remove []
	<FUNCTION> <NEW> "(" tf_port_list() ")" <SEMICOLON>
}

void class_constraint() :
{
}
{
  (
	constraint_prototype()
	| constraint_declaration()
  )
}

void class_item_qualifier() :
{
}
{
  (
	<STATIC>
	| <PROTECTED>
	| <LOCAL>
  )
}

void property_qualifier() :
{
}
{
  (
	random_qualifier()
	| class_item_qualifier()
  )
}

void random_qualifier() :
{
}
{
  (
	<RAND>
	| <RANDC>
  )
}

void method_qualifier () :
{
}
{
  (
	<VIRTUAL>
	| class_item_qualifier()
  )
}

void method_prototype() :
{
}
{
  (
	task_prototype()
	| function_prototype()
  )
}

void class_constructor_declaration() :
{
}
{
	// CHG: tf_port_list can expand to "", so remove []
	<FUNCTION> [ class_scope() ] <NEW> [ "(" tf_port_list() ")" ] <SEMICOLON>
	(block_item_declaration())*
	[ <SUPER> "." <NEW> [ "(" list_of_arguments() ")" ] <SEMICOLON> ]
	(function_statement_or_null())*
	<ENDFUNCTION> [ ":" <NEW> ]
}

/****************************************************************************
 * A.1.9 Constraints
 ****************************************************************************/
 
void constraint_declaration() :
{
}
{
	[ <STATIC> ] <CONSTRAINT> constraint_identifier() constraint_block()
}

void constraint_block() :
{
}
{
	"{" ( constraint_block_item() )* "}"
}

void constraint_block_item() :
{
}
{
	<SOLVE> identifier_list() <BEFORE> identifier_list() <SEMICOLON>
	| constraint_expression()
}

void constraint_expression() :
{
}
{
	expression_or_dist() <SEMICOLON>
	| expression() ("–>") constraint_set()
	| <IF> "(" expression() ")" constraint_set() [ <ELSE> constraint_set() ]
	| <FOREACH> "(" array_identifier() [ loop_variables() ] ")" constraint_set()
}

void constraint_set() :
{
}
{
	constraint_expression()
	| "{" ( constraint_expression() )* "}"
}

void dist_list() :
{
}
{
	dist_item() ( "," dist_item() )*
}

void dist_item() :
{
}
{
	value_range() [ dist_weight() ]
}

void dist_weight() :
{
}
{
	":=" expression()
	| ":/" expression()
}

void constraint_prototype() :
{
}
{
	[ <STATIC> ] <CONSTRAINT> constraint_identifier() <SEMICOLON>
}

void extern_constraint_declaration() :
{
}
{
	[ <STATIC> ] <CONSTRAINT> class_scope() constraint_identifier() constraint_block()
}

void identifier_list() :
{
}
{
	identifier() ( "," identifier() )*
}

/****************************************************************************
 * A.1.10 Package items
 ****************************************************************************/
void package_item() :
{
}
{
  (
	package_or_generate_item_declaration() 
	| anonymous_program()
	| timeunits_declaration()
  )
}

void package_or_generate_item_declaration() :
{
}
{
  (
	net_declaration()
	| data_declaration()
	| task_declaration()
	| function_declaration()
	| dpi_import_export()
	| extern_constraint_declaration()
	| class_declaration()
	| class_constructor_declaration()
	| parameter_declaration() <SEMICOLON>
	| local_parameter_declaration()
	| covergroup_declaration()
	| overload_declaration()
	| concurrent_assertion_item_declaration()
	| <SEMICOLON>
  )
}

void anonymous_program() :
{
}
{
	<PROGRAM>  <SEMICOLON> (anonymous_program_item())* <ENDPROGRAM>
}

void anonymous_program_item() :
{
}
{
  (
	task_declaration()
	| function_declaration()
	| class_declaration()
	| covergroup_declaration()
	| class_constructor_declaration()
	| <SEMICOLON>
  )
}

/****************************************************************************
 * A.2 Declarations
 ****************************************************************************/
 
/********************************************************************
 * A.2.1 Declaration types
 ********************************************************************/

/********************************************************************
 * A.2.1.1 Module parameter declarations
 ********************************************************************/
void local_parameter_declaration() :
{
}
{
  (
	<LOCALPARAM> data_type_or_implicit() list_of_param_assignments() <SEMICOLON>
	| <LOCALPARAM> <TYPE> list_of_type_assignments() <SEMICOLON>
  )
}

void parameter_declaration() :
{
}
{
  (
	<PARAMETER> data_type_or_implicit() list_of_param_assignments()
	| <PARAMETER> <TYPE> list_of_type_assignments()
  )
}

void specparam_declaration() :
{
}
{
	<SPECPARAM> [ packed_dimension() ] list_of_specparam_assignments() <SEMICOLON>
}

/********************************************************************
 * A.2.1.2 Port declarations 
 ********************************************************************/
 
void inout_declaration() :
{
}
{
	<INOUT> net_port_type() list_of_port_identifiers()
}

void input_declaration() :
{
}
{
  (
	<INPUT> net_port_type() list_of_port_identifiers()
	| <INPUT> variable_port_type() list_of_variable_identifiers()
  )
}

void output_declaration() :
{
}
{
  (
	<OUTPUT> net_port_type() list_of_port_identifiers()
	| <OUTPUT> variable_port_type() list_of_variable_port_identifiers()
  )
}

void interface_port_declaration() :
{
}
{
  (
	interface_identifier() list_of_interface_identifiers()
	| interface_identifier() "." modport_identifier() list_of_interface_identifiers()
  )
}

void ref_declaration() :
{
}
{
	<REF> variable_port_type() list_of_port_identifiers()
}

/********************************************************************
 * A.2.1.3 Type declarations 
 ********************************************************************/
 
void data_declaration() :
{
}
{
  (
	[ <CONST> ] [ <VAR> ] [ lifetime() ] data_type_or_implicit() list_of_variable_decl_assignments() <SEMICOLON>
	| type_declaration()
	| package_import_declaration()
	| virtual_interface_declaration()
  )
}

void package_import_declaration() :
{
}
{
	<IMPORT> package_import_item() ("," package_import_item())* <SEMICOLON>
}

void package_import_item() :
{
}
{
  (
	package_identifier() "::" identifier()
	| package_identifier() "::" "*"
  )
}

void genvar_declaration() :
{
}
{
	<GENVAR> list_of_genvar_identifiers() <SEMICOLON>
}

void net_declaration() :
{
}
{
	net_type() [ drive_strength() | charge_strength() ] [ <VECTORED> | <SCALARED> ]
	data_type_or_implicit() [ delay3() ] list_of_net_decl_assignments() <SEMICOLON>
}

void type_declaration() :
{
}
{
  (
	<TYPEDEF> data_type() type_identifier() (variable_dimension())* <SEMICOLON>
	| <TYPEDEF> interface_instance_identifier() "." type_identifier() type_identifier() <SEMICOLON>
	| <TYPEDEF> [ <ENUM> | <STRUCT> | <UNION> | <CLASS> ] type_identifier() <SEMICOLON>
  )
}

void lifetime() :
{
}
{
	(<STATIC> | <AUTOMATIC>)
}


/********************************************************************
 * A.2.2 Declaration data types
 ********************************************************************/


/********************************************************************
 * A.2.2.1 Net and variable types  
 ********************************************************************/
 
void casting_type() :
{
}
{
	/* FIXME: eliminate constant_primary() as a casting type to
	 * eliminate left recursion
	simple_type() | constant_primary() | signing()
	 */
	simple_type() | signing()
}

void data_type() :
{
}
{
  (
	integer_vector_type() [ signing() ] (packed_dimension())*
	| integer_atom_type() [ signing() ]
	| non_integer_type()
	| struct_union() [ <PACKED> [ signing() ] ] (struct_union_member() (struct_union_member())*)*
	(packed_dimension())*
	| <ENUM> [enum_base_type()] (enum_name_declaration() ("," enum_name_declaration())*)*
	| <STRING>
	| <CHANDLE>
	| <VIRTUAL> [ <INTERFACE> ] interface_identifier()
	| [ class_scope() | package_scope() ] type_identifier() (packed_dimension())*
	| class_type()
	| <EVENT>
	| ps_covergroup_identifier()
	| type_reference()
  )
}

void data_type_or_implicit() :
{
}
{
  (
	data_type()
	| [signing()] (packed_dimension())*
  )
}

void enum_base_type() :
{
}
{
  (
	integer_atom_type() [signing()]
	| integer_vector_type() [signing()] [packed_dimension()]
	| type_identifier() [packed_dimension()]
  )
}

void enum_name_declaration() :
{
}
{
	enum_identifier() [ "[" integral_number() [ ":" integral_number() ] "]" ] [ "=" constant_expression() ]
}

void class_scope() :
{
}
{
	class_type() "::"
}

void class_type() :
{
}
{
	ps_class_identifier() [ parameter_value_assignment() ]
	( "::" class_identifier() [ parameter_value_assignment() ])*
}

void integer_type() :
{
}
{
	integer_vector_type() | integer_atom_type()
}

void integer_atom_type() :
{
}
{
	<BYTE> | <SHORTINT> | <INT> | <LONGINT> | <INTEGER> | <TIME>
}

void integer_vector_type() :
{
}
{
	<BIT> | <LOGIC> | <REG>
}

void non_integer_type() :
{
}
{
	<SHORTREAL> | <REAL> | <REALTIME>
}

void net_type() :
{
}
{
	<SUPPLY0> | <SUPPLY1> | <TRI> | <TRIAND> | <TRIOR> | <TRIREG> |
	<TRI0> | <TRI1> | <UWIRE> | <WIRE> | <WAND> | <WOR>
}

void net_port_type() :
{
}
{
	[net_type()] data_type_or_implicit()
}

void variable_port_type() :
{
}
{
	var_data_type()
}

void var_data_type() :
{
}
{
	data_type() | <VAR> data_type_or_implicit()
}

void signing() :
{
}
{
	<SIGNED> | <UNSIGNED>
}

void simple_type() :
{
}
{
	integer_type() | non_integer_type() | ps_type_identifier() | ps_parameter_identifier()
}

void struct_union_member() :
{
}
{ 
	(attribute_instance())* [random_qualifier()] data_type_or_void() list_of_variable_decl_assignments() <SEMICOLON>
}

void data_type_or_void() :
{
}
{
	data_type() | <VOID>
}

void struct_union() :
{
}
{
	<STRUCT> | <UNION> [ <TAGGED> ]
}

void type_reference() :
{
}
{
	<TYPE> "(" expression() ")"
	| <TYPE> "(" data_type() ")"
}

/********************************************************************
 * A.2.2.2 Strengths  
 ********************************************************************/
 
void drive_strength() :
{
}
{
	"(" strength0() "," strength1() ")"
	| "(" strength1() "," strength0() ")"
	| "(" strength0() "," <HIGHZ1> ")"
	| "(" strength1() "," <HIGHZ0> ")"
	| "(" <HIGHZ0> "," strength1() ")"
	| "(" <HIGHZ1> "," strength0() ")"
}

void strength0() :
{
}
{
	<SUPPLY0> | <STRONG0> | <PULL0> | <WEAK0>
}

void strength1() :
{
}
{
	<SUPPLY1> | <STRONG1> | <PULL1> | <WEAK1>
}

void charge_strength() :
{
}
{
	"(" <SMALL> ")" | "(" <MEDIUM> ")" | "(" <LARGE> ")"
}


/********************************************************************
 * A.2.2.3 Delays  
 ********************************************************************/
void delay3() :
{
}
{
  (
	"#" delay_value() 
	| "#" "(" mintypmax_expression() [ "," mintypmax_expression() [ "," mintypmax_expression() ]] ")"
  )
}

void delay2() :
{
}
{
  (
	"#" delay_value() 
	| "#" "(" mintypmax_expression() [ "," mintypmax_expression() ] ")"
  )
}

void delay_value() :
{
}
{
  (
	unsigned_number()
	| real_number()
	| ps_identifier()
	| time_literal()
  )
}

/********************************************************************
 * A.2.3 Declaration lists  
 ********************************************************************/

void list_of_defparam_assignments() :
{
}
{
	defparam_assignment() ( "," defparam_assignment())*
}

void list_of_genvar_identifiers() :
{
}
{
	genvar_identifier() ( "," genvar_identifier())*
}

void list_of_interface_identifiers() :
{
}
{
	interface_identifier() ( unpacked_dimension())*
	( "," interface_identifier() ( unpacked_dimension())* )*
}

void list_of_net_decl_assignments() :
{
}
{
	net_decl_assignment() ( "," net_decl_assignment())*
}

void list_of_param_assignments() :
{
}
{
	param_assignment() ( "," param_assignment() )*
}

void list_of_port_identifiers() :
{
}
{
	port_identifier() ( unpacked_dimension())*
	( "," port_identifier() ( unpacked_dimension())* )*
}

void list_of_udp_port_identifiers() :
{
}
{
	port_identifier() ( "," port_identifier())*
}

void list_of_specparam_assignments() :
{
}
{
	specparam_assignment() ( "," specparam_assignment())*
}

void list_of_tf_variable_identifiers() :
{
}
{
	port_identifier() ( variable_dimension())* [ "=" expression() ]
	( "," port_identifier() ( variable_dimension())* [ "=" expression() ] )*
}

void list_of_type_assignments() :
{
}
{
	type_assignment() ( "," type_assignment())*
}

void list_of_variable_decl_assignments() :
{
}
{
	variable_decl_assignment() ( "," variable_decl_assignment())*
}

void list_of_variable_identifiers() :
{
}
{
	variable_identifier() ( variable_dimension() )*
	( "," variable_identifier() ( variable_dimension() )* )*
}

void list_of_variable_port_identifiers() :
{
}
{
	port_identifier() ( variable_dimension())* [ "=" constant_expression() ]
	("," port_identifier() (variable_dimension())* ["=" constant_expression()])*
}

void list_of_virtual_interface_decl() :
{
}
{
	variable_identifier() [ "=" interface_instance_identifier() ]
	( "," variable_identifier() ["=" interface_instance_identifier()])*
}

/********************************************************************
 * A.2.4 Declaration assignments  
 ********************************************************************/

void defparam_assignment() :
{
}
{
	hierarchical_parameter_identifier() "=" constant_mintypmax_expression()
}

void net_decl_assignment() :
{
}
{
	net_identifier() (unpacked_dimension())* [ "=" expression() ]
}

void param_assignment() :
{
}
{
	parameter_identifier() (unpacked_dimension())* "=" constant_param_expression()
}

void specparam_assignment() :
{
}
{
	specparam_identifier() "=" constant_mintypmax_expression()
	| pulse_control_specparam()
}

void type_assignment() :
{
}
{
	type_identifier() "=" data_type()
}

void pulse_control_specparam() :
{
}
{
	<PATHPULSE> "=" "(" reject_limit_value() [ "," error_limit_value() ] ")"
	| <PATHPULSE> specify_input_terminal_descriptor() "$" specify_output_terminal_descriptor()
		"=" "(" reject_limit_value() [ "," error_limit_value() ] ")"
}

void error_limit_value() :
{
}
{
	limit_value()
}

void reject_limit_value() :
{
}
{
	limit_value()
}

void limit_value() :
{
}
{
	constant_mintypmax_expression()
}

void variable_decl_assignment() :
{
}
{
	variable_identifier() ( variable_dimension() )* [ "=" expression() ]
	| dynamic_array_variable_identifier() "[" "]" [ "=" dynamic_array_new() ]
	| class_variable_identifier() [ "=" class_new() ]
	| [ covergroup_variable_identifier() ] "=" <NEW> [ "(" list_of_arguments() ")" ]
}

void class_new() :
{
}
{
	//  CHG: expression() can expand to "", so move ]
	// FIXME: I think this leaves a hole
	// <NEW> [ "(" list_of_arguments() ")" | expression() ]
	<NEW> [ "(" list_of_arguments() ")" ] expression()
}

void dynamic_array_new() :
{
}
{
	<NEW> "[" expression() "]" [ "(" expression() ")" ]
}

/********************************************************************
 * A.2.5 Declaration ranges  
 ********************************************************************/
void unpacked_dimension() :
{
}
{
	"[" constant_range() "]"
	| "[" constant_expression() "]"
}

void packed_dimension() :
{
}
{
	"[" constant_range() "]"
	| unsized_dimension()
}

void associative_dimension() :
{
}
{
	"[" data_type() "]"
	| "[" "*" "]"
}

void variable_dimension() :
{
}
{
	unsized_dimension()
	| unpacked_dimension()
	| associative_dimension()
	| queue_dimension()
}

void queue_dimension() :
{
}
{
	"[" "$" [ ":" constant_expression() ] "]"
}

void unsized_dimension() :
{
}
{
	"[" "]"
}

/********************************************************************
 * A.2.6 Function declarations  
 ********************************************************************/
 
void function_data_type() :
{
}
{
	data_type() | <VOID>
}

void function_data_type_or_implicit() :
{
}
{
	function_data_type()
	| [ signing() ] ( packed_dimension() )*
}

void function_declaration() :
{
}
{
	<FUNCTION> [ lifetime() ] function_body_declaration()
}

void function_body_declaration() :
{
}
{
	function_data_type_or_implicit()
	[ interface_identifier() "." | class_scope() ] function_identifier() <SEMICOLON>
	( tf_item_declaration() )*
	( function_statement_or_null() )*
	<ENDFUNCTION> [ ":" function_identifier() ]
	| function_data_type_or_implicit()
	
	// CHG: tf_port_list() can expand to "", so remove []
	[ interface_identifier() "." | class_scope() ] function_identifier() "(" tf_port_list() ")" <SEMICOLON>
	( block_item_declaration() )*
	( function_statement_or_null() )*
	<ENDFUNCTION> [ ":" function_identifier() ]
}

void function_prototype() :
{
}
{
	// CHG: tf_port_list() can expand to "", so remove []
	<FUNCTION> function_data_type() function_identifier() "(" tf_port_list() ")"
}

void dpi_import_export() :
{
}
{
	<IMPORT> dpi_spec_string() [ dpi_function_import_property() ] [ c_identifier() "=" ] dpi_function_proto() <SEMICOLON>
	| <IMPORT> dpi_spec_string() [ dpi_task_import_property() ] [ c_identifier() "=" ] dpi_task_proto() <SEMICOLON>
	| <EXPORT> dpi_spec_string() [ c_identifier() "=" ] <FUNCTION> function_identifier() <SEMICOLON>
	| <EXPORT> dpi_spec_string() [ c_identifier() "=" ] <TASK> task_identifier() <SEMICOLON>
}

void dpi_spec_string() :
{
}
{
	"\"DPI-C\"" | "\"DPI\""
}

void dpi_function_import_property() :
{
}
{
	<CONTEXT> | <PURE>
}

void dpi_task_import_property() :
{
}
{
	<CONTEXT>
}

void dpi_function_proto() :
{
}
{
	function_prototype()
}

void dpi_task_proto() :
{
}
{
	task_prototype()
} 

/********************************************************************
 * A.2.7 Task declarations  
 ********************************************************************/
void task_declaration() :
{
}
{
	<TASK> [ lifetime() ] task_body_declaration()
}

void task_body_declaration() :
{
}
{
	[ interface_identifier() "." | class_scope() ] task_identifier() <SEMICOLON>
	( tf_item_declaration() )*
	( statement_or_null() )*
	<ENDTASK> [ ":" task_identifier() ]
	// CHG: tf_port_list() can expand to "", so remove []
	| [ interface_identifier() "." | class_scope() ] task_identifier() "(" tf_port_list() ")" <SEMICOLON>
	( block_item_declaration() )*
	( statement_or_null() )*
	<ENDTASK> [ ":" task_identifier() ]
}

void tf_item_declaration() :
{
}
{
	block_item_declaration()
	| tf_port_declaration()
}

void tf_port_list() :
{
}
{
	tf_port_item() ( "," tf_port_item() )*
}

void tf_port_item() :
{
}
{
	( attribute_instance() )*
	[ tf_port_direction() ] [ <VAR> ] data_type_or_implicit()
	[ port_identifier() ( variable_dimension() )* [ "=" expression() ] ]
}

void tf_port_direction() :
{
}
{
	port_direction() | <CONST> <REF>
}

void tf_port_declaration() :
{
}
{
	( attribute_instance() )* tf_port_direction() [ <VAR> ] data_type_or_implicit() list_of_tf_variable_identifiers() <SEMICOLON>
}

void task_prototype() :
{
}
{
	// CHG: tf_port_list() can expand to "", so remove []
	<TASK> task_identifier() "(" tf_port_list() ")"
}

/********************************************************************
 * A.2.8 Block item declarations  
 ********************************************************************/
void block_item_declaration() :
{
}
{
  (
	(attribute_instance())* data_declaration()
	| (attribute_instance())* local_parameter_declaration()
	| (attribute_instance())* parameter_declaration() <SEMICOLON>
	| (attribute_instance())* overload_declaration()
  )
}

void overload_declaration() :
{
}
{
	<BIND> overload_operator() <FUNCTION> data_type() function_identifier() "(" overload_proto_formals() ")" <SEMICOLON>
}

void overload_operator() :
{
}
{
	("+" | "++" | "–" | "––" | "*" | "**" | "/" | "%" | "==" | "!=" | "<" | "<=" | ">" | ">=" | "=")
}

void overload_proto_formals() :
{
}
{
	data_type() ( "," data_type() )*
}

/********************************************************************
 * A.2.9 Interface declarations  
 ********************************************************************/
 
void virtual_interface_declaration() :
{
}
{
	<VIRTUAL> [ <INTERFACE> ] interface_identifier() list_of_virtual_interface_decl() <SEMICOLON>
}

void modport_declaration() :
{
}
{
	<MODPORT> modport_item() ( "," modport_item() )* <SEMICOLON>
}

void modport_item() :
{
}
{
	modport_identifier() "(" modport_ports_declaration() ("," modport_ports_declaration())* ")"
}

void modport_ports_declaration() :
{
}
{
  (
	(attribute_instance())* modport_simple_ports_declaration()
	| (attribute_instance())* modport_tf_ports_declaration()
	| (attribute_instance())* modport_clocking_declaration()
  )
}

void modport_clocking_declaration() :
{
}
{
	<CLOCKING> clocking_identifier()
}

void modport_simple_ports_declaration() :
{
}
{
	port_direction() modport_simple_port() ( "," modport_simple_port())*
}

void modport_simple_port() :
{
}
{
  (
	port_identifier()
	// CHG: expression() can expand to "", so remove[]
	| "." port_identifier() "(" expression() ")"
  )
}

void modport_tf_ports_declaration() :
{
}
{
	import_export() modport_tf_port() ( "," modport_tf_port())*
}

void modport_tf_port() :
{
}
{
  (
	method_prototype()
	| tf_identifier()
  )
}

void import_export() :
{
}
{
	<IMPORT> | <EXPORT>
}

/********************************************************************
 * A.2.10 Assertion declarations
 ********************************************************************/

void concurrent_assertion_item() :
{
}
{
	[ block_identifier() ":" ] concurrent_assertion_statement()
}

void concurrent_assertion_statement() :
{
}
{
	assert_property_statement()
	| assume_property_statement()
	| cover_property_statement()
}

void assert_property_statement() :
{
}
{
	<ASSERT> <PROPERTY> "(" property_spec() ")" action_block()
}

void assume_property_statement() :
{
}
{
	<ASSUME> <PROPERTY> "(" property_spec() ")" <SEMICOLON>
}

void cover_property_statement() :
{
}
{
	<COVER> <PROPERTY> "(" property_spec() ")" statement_or_null()
}

void expect_property_statement() :
{
}
{
	<EXPECT> "(" property_spec() ")" action_block()
}

void property_instance() :
{
}
{
	// CHG: list_of_arguments() can expand to "", so remove []
	ps_property_identifier() [ "(" list_of_arguments() ")" ]
}

void concurrent_assertion_item_declaration() :
{
}
{
	property_declaration()
	| sequence_declaration()
}

void property_declaration() :
{
}
{
	// CHG: tf_port_list() can expand to "", so remove []
	<PROPERTY> property_identifier() [ "(" tf_port_list() ")" ] <SEMICOLON>
	(assertion_variable_declaration())*
	property_spec() <SEMICOLON>
	<ENDPROPERTY> [ ":" property_identifier() ]
}

void property_spec() :
{
}
{
	[clocking_event() ] [ <DISABLE> <IFF> "(" expression_or_dist() ")" ] property_expr()
}

void property_expr() :
{
}
{
    /* CHG: eliminate left recursion
	sequence_expr()
	| "(" property_expr() ")"
	| <NOT> property_expr()
	| property_expr() <OR> property_expr()
	| property_expr() <AND> property_expr()
	| sequence_expr() "|->" property_expr()
	| sequence_expr() "|=>" property_expr()
	| <IF> "(" expression_or_dist() ")" property_expr() [ <ELSE> property_expr() ]
	| property_instance()
	| clocking_event() property_expr()
	 */
  (
	sequence_expr()
	| "(" property_expr() ")"
	| <NOT> property_expr()
	| sequence_expr() "|->" property_expr()
	| sequence_expr() "|=>" property_expr()
	| <IF> "(" expression_or_dist() ")" property_expr() [ <ELSE> property_expr() ]
	| property_instance()
	| clocking_event() property_expr()
  ) [property_expr_2()]
	
}

void property_expr_2() :
{
}
{
  (
	<OR> property_expr()  |
	<AND> property_expr()
  ) property_expr()

}

void sequence_declaration() :
{
}
{
	// CHG: tf_port_list() can expand to "", so remove []
	<SEQUENCE> sequence_identifier() [ "(" tf_port_list() ")" ] <SEMICOLON>
	(assertion_variable_declaration())*
	sequence_expr() <SEMICOLON>
	<ENDSEQUENCE> [ ":" sequence_identifier() ]
}

void sequence_expr() :
{
}
{
	/* CHG: eliminate left recursion
	cycle_delay_range() sequence_expr() ( cycle_delay_range() sequence_expr())*
	| sequence_expr() cycle_delay_range() sequence_expr() (cycle_delay_range() sequence_expr())*
	| expression_or_dist() [ boolean_abbrev() ]
	| "(" expression_or_dist() ("," sequence_match_item())* ")" [ boolean_abbrev() ]
	| sequence_instance() [ sequence_abbrev() ]
	| "(" sequence_expr() ("," sequence_match_item())* ")" [ sequence_abbrev() ]
	| sequence_expr() <AND> sequence_expr()
	| sequence_expr() <INTERSECT> sequence_expr()
	| sequence_expr() <OR> sequence_expr()
	| <FIRST_MATCH> "(" sequence_expr() ("," sequence_match_item())* ")"
	| expression_or_dist() <THROUGHOUT> sequence_expr()
	| sequence_expr() <WITHIN> sequence_expr()
	| clocking_event() sequence_expr()
	 */
  (
	cycle_delay_range() sequence_expr() ( cycle_delay_range() sequence_expr())*
	| expression_or_dist() [ boolean_abbrev() ]
	| "(" expression_or_dist() ("," sequence_match_item())* ")" [ boolean_abbrev() ]
	| sequence_instance() [ sequence_abbrev() ]
	| "(" sequence_expr() ("," sequence_match_item())* ")" [ sequence_abbrev() ]
	| <FIRST_MATCH> "(" sequence_expr() ("," sequence_match_item())* ")"
	| expression_or_dist() <THROUGHOUT> sequence_expr()
	| clocking_event() sequence_expr()
  ) [ sequence_expr_2() ]
}

void sequence_expr_2() :
{
}
{
  (
	cycle_delay_range() sequence_expr() (cycle_delay_range() sequence_expr())*
	| <AND> sequence_expr()
	| <INTERSECT> sequence_expr()
	| <OR> sequence_expr()
	| <WITHIN> sequence_expr()
  ) sequence_expr()
}

void cycle_delay_range() :
{
}
{
	"##" integral_number()
	| "##" identifier()
	| "##" "(" constant_expression() ")"
	| "##" [ cycle_delay_const_range_expression() ]
}

void sequence_method_call() :
{
}
{
	sequence_instance() "." method_identifier()
}

void sequence_match_item() :
{
}
{
	operator_assignment()
	| inc_or_dec_expression()
	| subroutine_call()
}

void sequence_instance() :
{
}
{
	// CHG: list_of_arguments() can expand to "", so remove []
	ps_sequence_identifier() [ "(" list_of_arguments() ")" ]
}

void formal_list_item() :
{
}
{
	formal_identifier() [ "=" actual_arg_expr() ]
}

void list_of_formals() :
{
}
{
	formal_list_item() ( "," formal_list_item() )*
}

void actual_arg_expr() :
{
}
{
	event_expression()
	| "$"
}

void boolean_abbrev() :
{
}
{
	consecutive_repetition()
	| non_consecutive_repetition()
	| goto_repetition()
}

void sequence_abbrev() :
{
}
{
	consecutive_repetition()
}

void consecutive_repetition() :
{
}
{
	"[*" const_or_range_expression() "]"
}

void non_consecutive_repetition() :
{
}
{
	"[=" const_or_range_expression() "]"
}

void goto_repetition() :
{
}
{
	"[->" const_or_range_expression() "]"
}

void const_or_range_expression() :
{
}
{
	constant_expression()
	| cycle_delay_const_range_expression()
}

void cycle_delay_const_range_expression() :
{
}
{
	constant_expression() ":" constant_expression()
	| constant_expression() ":" "$"
}

void expression_or_dist() :
{
}
{
	expression() [ <DIST> "{" dist_list() "}" ]
}

void assertion_variable_declaration() :
{
}
{
	var_data_type() list_of_variable_identifiers() <SEMICOLON>
}

 
/********************************************************************
 * A.2.11 Covergroup declarations  
 ********************************************************************/
void covergroup_declaration() :
{
}
{
	// CHG: tf_port_list() can expand to "", so remove []
	<COVERGROUP> covergroup_identifier() [ "(" tf_port_list() ")" ] [ coverage_event() ] <SEMICOLON>
	( coverage_spec_or_option() )*
	<ENDGROUP> [ ":" covergroup_identifier() ]
}

void coverage_spec_or_option() :
{
}
{
	( attribute_instance() )* coverage_spec()
	| ( attribute_instance() )* coverage_option() <SEMICOLON>
}

void coverage_option() :
{
}
{
	<OPTION> "." member_identifier() "=" expression()
	| <TYPE_OPTION> "." member_identifier() "=" expression()
}

void coverage_spec() :
{
}
{
	cover_point()
	| cover_cross()
}

void coverage_event() :
{
}
{
	clocking_event()
	| "@@" "(" block_event_expression() ")"
}

void block_event_expression() :
{
}
{
	// CHG: eliminate left recursion
	// A -> Aa | b
	//
	// A  -> bA'
	// A' -> aA' | eta
	//
	// b  -> (<BEGIN> ... | <END> ...)
	// a  -> (<OR> block_event_expression())
	//
	// 
	/*
	block_event_expression() <OR> block_event_expression()
	| <BEGIN> hierarchical_btf_identifier()
	| <END> hierarchical_btf_identifier()
	 */
	(<BEGIN> hierarchical_btf_identifier()
		| <END> hierarchical_btf_identifier()
	) [block_event_expression_2()]
}

void block_event_expression_2() :
{
}
{
	<OR> block_event_expression() block_event_expression_2()
}


void hierarchical_btf_identifier() :
{
}
{
	hierarchical_tf_identifier()
	| hierarchical_block_identifier()
	| hierarchical_identifier() [ class_scope() ] method_identifier()
}

void cover_point() :
{
}
{
	[ cover_point_identifier() ":" ] <COVERPOINT> expression() [ <IFF> "(" expression() ")" ] bins_or_empty()
}

void bins_or_empty() :
{
}
{
	"{" (attribute_instance() )* ( bins_or_options() <SEMICOLON> )*  "}"
	| <SEMICOLON>
}

void bins_or_options() :
{
}
{
	coverage_option()
	// CHG: expression can expand to "", so remove []
	| [ <WILDCARD> ] bins_keyword() bin_identifier() [ "[" expression() "]" ] "=" "{" open_range_list() "}" [ <IFF> "(" expression() ")" ]
	| [ <WILDCARD> ] bins_keyword() bin_identifier() [ "[" "]" ] "=" trans_list() [ <IFF> "(" expression() ")" ]
	// CHG: expression can expand to "", so remove []
	| bins_keyword() bin_identifier() [ "[" expression() "]" ] "=" <T_DEFAULT> [ <IFF> "(" expression() ")" ]
	| bins_keyword() bin_identifier() "=" <T_DEFAULT> <SEQUENCE> [ <IFF> "(" expression() ")" ]
}

void bins_keyword () :
{
}
{
	<BINS> | <ILLEGAL_BINS> | <IGNORE_BINS>
}

void range_list() :
{
}
{
	value_range() ( "," value_range() )*
}

void trans_list() :
{
}
{
	"(" trans_set() ")" ( "," "(" trans_set() ")" )*
}

void trans_set() :
{
}
{
	trans_range_list() ( "=>" trans_range_list() )*
}

void trans_range_list() :
{
}
{
	trans_item()
	| trans_item() [ "[" "*" repeat_range() "]" ]
	| trans_item() [ "[" "–>" repeat_range() "]" ]
	| trans_item() [ "[" "=" repeat_range() "]" ]
}

void trans_item() :
{
}
{
	range_list()
}

void repeat_range() :
{
}
{
	expression()
	| expression() ":" expression()
}

void cover_cross() :
{
}
{
	[ cover_point_identifier() ":" ] <CROSS> list_of_coverpoints() [ <IFF> "(" expression() ")" ]
	select_bins_or_empty()
}

void list_of_coverpoints() :
{
}
{
	cross_item() "," cross_item() ( "," cross_item() )*
}

void cross_item() :
{
}
{
	cover_point_identifier()
	| variable_identifier()
}

void select_bins_or_empty() :
{
}
{
	"{" ( bins_selection_or_option() <SEMICOLON> )* "}"
	| <SEMICOLON>
}

void bins_selection_or_option() :
{
}
{
	( attribute_instance() )* coverage_option()
	| ( attribute_instance() )* bins_selection()
}

void bins_selection() :
{
}
{
	bins_keyword() bin_identifier() "=" select_expression() [ <IFF> "(" expression() ")" ]
}

void select_expression() :
{
}
{
    /* CHG: remove left recursion
	select_condition()
	| "!" select_condition()
	| select_expression() "&&" select_expression()
	| select_expression() "||" select_expression()
	| "(" select_expression() ")"
	 */
  (
	select_condition()
	| "!" select_condition()
	| "(" select_expression() ")"
  ) [select_expression_2()]
}

void select_expression_2() :
{
}
{
  (
	  "&&" select_expression()
	| "||" select_expression()
  ) select_expression()
}


void select_condition() :
{
}
{
	<BINSOF> "(" bins_expression() ")" [ <INTERSECT> "{" open_range_list() "}" ]
}

void bins_expression() :
{
}
{
	variable_identifier()
	// ISSUE: spec says bins_identifier()
	| cover_point_identifier() [ "." bin_identifier() ]
}

void open_range_list() :
{
}
{
	open_value_range() ( "," open_value_range() )*
}

void open_value_range() :
{
}
{
	value_range()
}

/****************************************************************************
 * A.3 Primitive instances
 ****************************************************************************/

/********************************************************************
 * A.3.1 Primitive instantiation and instances
 ********************************************************************/

void gate_instantiation() :
{
}
{
	cmos_switchtype() [delay3()] cmos_switch_instance() ( "," cmos_switch_instance() )* <SEMICOLON>
	| enable_gatetype() [drive_strength()] [delay3()] enable_gate_instance() ( "," enable_gate_instance() )* <SEMICOLON>
	| mos_switchtype() [delay3()] mos_switch_instance() ( "," mos_switch_instance() )* <SEMICOLON>
	| n_input_gatetype() [drive_strength()] [delay2()] n_input_gate_instance() ( "," n_input_gate_instance() )* <SEMICOLON>
	| n_output_gatetype() [drive_strength()] [delay2()] n_output_gate_instance() ( "," n_output_gate_instance() )* <SEMICOLON>
	| pass_en_switchtype() [delay2()] pass_enable_switch_instance() ( "," pass_enable_switch_instance() )* <SEMICOLON>
	| pass_switchtype() pass_switch_instance() ( "," pass_switch_instance() )* <SEMICOLON>
	| <PULLDOWN> [pulldown_strength()] pull_gate_instance() ( "," pull_gate_instance() )* <SEMICOLON>
	| <PULLUP> [pullup_strength()] pull_gate_instance() ( "," pull_gate_instance() )* <SEMICOLON>
}

void cmos_switch_instance() :
{
}
{
	[ name_of_instance() ] "(" output_terminal() "," input_terminal() "," ncontrol_terminal() "," pcontrol_terminal() ")"
}

void enable_gate_instance() :
{
}
{
	[ name_of_instance() ] "(" output_terminal() "," input_terminal() "," enable_terminal() ")"
}

void mos_switch_instance() :
{
}
{
	[ name_of_instance() ] "(" output_terminal() "," input_terminal() "," enable_terminal() ")"
}

void n_input_gate_instance() :
{
}
{
	[ name_of_instance() ] "(" output_terminal() "," input_terminal() ( "," input_terminal() )* ")"
}

void n_output_gate_instance() :
{
}
{
	[ name_of_instance() ] "(" output_terminal() ( "," output_terminal() )* "," input_terminal() ")"
}

void pass_switch_instance() :
{
}
{
	[ name_of_instance() ] "(" inout_terminal() "," inout_terminal() ")"
}

void pass_enable_switch_instance() :
{
}
{
	[ name_of_instance() ] "(" inout_terminal() "," inout_terminal() "," enable_terminal() ")"
}

void pull_gate_instance() :
{
}
{
	[ name_of_instance() ] "(" output_terminal() ")"
}


/********************************************************************
 * A.3.2 Primitive strengths
 ********************************************************************/
void pulldown_strength() :
{
}
{
	"(" strength0() "," strength1() ")"
	| "(" strength1() "," strength0() ")"
	| "(" strength0() ")"
}

void pullup_strength() :
{
}
{
	"(" strength0() "," strength1() ")"
	| "(" strength1() "," strength0() ")"
	| "(" strength1() ")"
}


/********************************************************************
 * A.3.3 Primitive terminals
 ********************************************************************/

void enable_terminal() :
{
}
{
	expression()
}

void inout_terminal() :
{
}
{
	net_lvalue()
}

void input_terminal() :
{
}
{
	expression()
}

void ncontrol_terminal() :
{
}
{
	expression()
}

void output_terminal() :
{
}
{
	net_lvalue()
}

void pcontrol_terminal() :
{
}
{
	expression()
}

/********************************************************************
 * A.3.4 Primitive gate and switch types
 ********************************************************************/
void cmos_switchtype() :
{
}
{
	<CMOS> | <RCMOS>
}

void enable_gatetype() :
{
}
{
	<BUFIF0> | <BUFIF1> | <NOTIF0> | <NOTIF1>
}

void mos_switchtype() :
{
}
{
	<NMOS> | <PMOS> | <RNMOS> | <RPMOS>
}

void n_input_gatetype() :
{
}
{
	<AND> | <NAND> | <OR> | <NOR> | <XOR> | <XNOR>
}

void n_output_gatetype() :
{
}
{
	<BUF> | <NOT>
}

void pass_en_switchtype() :
{
}
{
	<TRANIF0> | <TRANIF1> | <RTRANIF1> | <RTRANIF0>
}

void pass_switchtype() :
{
}
{
	<TRAN> | <RTRAN>
}


/****************************************************************************
 * A.4 Module, interface and generated instantiation
 ****************************************************************************/
 
/********************************************************************
 * A.4.1.1 Module instantiation
 ********************************************************************/
 
void module_instantiation() :
{
}
{
	module_identifier() [ parameter_value_assignment() ] hierarchical_instance()
		( "," hierarchical_instance() )* <SEMICOLON>
}

void parameter_value_assignment() :
{
}
{
	// CHG: list_of_parameter_assignments can expand to "", so remove []
 	"#" "(" list_of_parameter_assignments() ")"
}
 
void list_of_parameter_assignments() :
{
}
{
	ordered_parameter_assignment() ( "," ordered_parameter_assignment() )*
	| named_parameter_assignment() ( "," named_parameter_assignment() )*
}

void ordered_parameter_assignment() :
{
}
{
	param_expression()
}

void named_parameter_assignment() :
{
}
{
	// CHG: param_expression() can expand to "", so remove []
	"." parameter_identifier() "(" param_expression() ")"
}

void hierarchical_instance() :
{
}
{
	// CHG: list_of_port_connections() can expand to "", so remove []
	name_of_instance() "(" list_of_port_connections() ")"
}

void name_of_instance() :
{
}
{
	instance_identifier() ( unpacked_dimension() )*
}

void list_of_port_connections() :
{
}
{
	ordered_port_connection() ( "," ordered_port_connection() )*
	| named_port_connection() ( "," named_port_connection() )*
}

void ordered_port_connection() :
{
}
{
	// CHG: expression() can expand to "", so remove []
	( attribute_instance() )* expression()
}

void named_port_connection() :
{
}
{
	// CHG: expression() can expand to [], so remove []
	( attribute_instance() )* "." port_identifier() [ "(" expression() ")" ]
	| ( attribute_instance() )* ".*"
}

/********************************************************************
 * A.4.1.2 Interface instantiation
 ********************************************************************/
 
void interface_instantiation() :
{
}
{
	interface_identifier() [ parameter_value_assignment() ] hierarchical_instance() ( "," hierarchical_instance())* <SEMICOLON>
}

/********************************************************************
 * A.4.1.3 Program instantiation
 ********************************************************************/

void program_instantiation() :
{
}
{
	program_identifier() [ parameter_value_assignment() ] hierarchical_instance() ("," hierarchical_instance())*
}

/********************************************************************
 * A.4.2 Generated instantiation
 ********************************************************************/

void module_or_interface_or_generate_item() :
{
}
{
	module_or_generate_item()
	| interface_or_generate_item()
}

void generate_region() :
{
}
{
	<GENERATE> ( module_or_interface_or_generate_item() )* <ENDGENERATE>
}

void loop_generate_construct() :
{
}
{
	<FOR> "(" genvar_initialization() <SEMICOLON> genvar_expression() <SEMICOLON> genvar_iteration() ")"
	generate_block()
}

void genvar_initialization() :
{
}
{
	[ <GENVAR> ] genvar_identifier() "=" constant_expression()
}

void genvar_iteration() :
{
}
{
	genvar_identifier() assignment_operator() genvar_expression()
	| inc_or_dec_operator() genvar_identifier()
	| genvar_identifier() inc_or_dec_operator()
}

void conditional_generate_construct() :
{
}
{
	if_generate_construct()
	| case_generate_construct()
}

void if_generate_construct() :
{
}
{
	<IF> "(" constant_expression() ")" generate_block_or_null() [ <ELSE> generate_block_or_null() ]
}

void case_generate_construct() :
{
}
{
	<CASE> "(" constant_expression() ")" case_generate_item() ( case_generate_item() )* <ENDCASE>
}

void case_generate_item() :
{
}
{
	constant_expression() ( "," constant_expression())* ":" generate_block_or_null()
	| <T_DEFAULT> [ ":" ] generate_block_or_null()
}

void generate_block() :
{
}
{
	module_or_interface_or_generate_item()
	| [ generate_block_identifier() ":" ] <BEGIN> [ ":" generate_block_identifier() ]
	( module_or_interface_or_generate_item() )*
	<END> [ ":" generate_block_identifier() ]
}

void generate_block_or_null() :
{
}
{
	generate_block() | <SEMICOLON>
}

/****************************************************************************
 * A.5 UDP declaration and instantiation
 ****************************************************************************/

/********************************************************************
 * A.5.1 UDP declaration
 ********************************************************************/

void udp_nonansi_declaration() :
{
}
{
	( attribute_instance() )* <PRIMITIVE> udp_identifier() "(" udp_port_list() ")" <SEMICOLON>
}

void udp_ansi_declaration() :
{
}
{
	( attribute_instance() )* <PRIMITIVE> udp_identifier() "(" udp_declaration_port_list() ")" <SEMICOLON>
}

void udp_declaration() :
{
}
{
	udp_nonansi_declaration() udp_port_declaration() ( udp_port_declaration() )*
	udp_body()
	<ENDPRIMITIVE> [ ":" udp_identifier() ]
	| udp_ansi_declaration()
	udp_body()
	<ENDPRIMITIVE> [ ":" udp_identifier() ]
	| <EXTERN> udp_nonansi_declaration()
	| <EXTERN> udp_ansi_declaration()
	| ( attribute_instance() )* <PRIMITIVE> udp_identifier() "(" ".*" ")" <SEMICOLON> ( udp_port_declaration() )*
	udp_body()
	<ENDPRIMITIVE> [ ":" udp_identifier() ]
}

/********************************************************************
 * A.5.2 UDP ports
 ********************************************************************/
void udp_port_list() :
{
}
{
	output_port_identifier() "," input_port_identifier() ( "," input_port_identifier() )*
}

void udp_declaration_port_list() :
{
}
{
	udp_output_declaration() "," udp_input_declaration() ( "," udp_input_declaration() )*
}

void udp_port_declaration() :
{
}
{
	udp_output_declaration() <SEMICOLON>
	| udp_input_declaration() <SEMICOLON>
	| udp_reg_declaration() <SEMICOLON>
}

void udp_output_declaration() :
{
}
{
	( attribute_instance() )* <OUTPUT> port_identifier()
	| ( attribute_instance() )* <OUTPUT> <REG> port_identifier() [ "=" constant_expression() ]
}

void udp_input_declaration() :
{
}
{
	( attribute_instance() )* <INPUT> list_of_udp_port_identifiers()
}

void udp_reg_declaration() :
{
}
{
	( attribute_instance() )* <REG> variable_identifier()
}

/********************************************************************
 * A.5.3 UDP body
 ********************************************************************/

void udp_body() :
{
}
{
	combinational_body() | sequential_body()
}

void combinational_body() :
{
}
{
	<TABLE> combinational_entry() ( combinational_entry() )* <ENDTABLE>
}

void combinational_entry() :
{
}
{
	level_input_list() ":" output_symbol() <SEMICOLON>
}

void sequential_body() :
{
}
{
	[ udp_initial_statement() ] <TABLE> sequential_entry() ( sequential_entry() )* <ENDTABLE>
}

void udp_initial_statement() :
{
}
{
	<INITIAL> output_port_identifier() "=" init_val() <SEMICOLON>
}

void init_val() :
{
}
{
	"1’b0" | "1’b1" | "1’bx" | "1’bX" | "1’B0" | "1’B1" | "1’Bx" | "1’BX" | "1" | "0"
}

void sequential_entry() :
{
}
{
	seq_input_list() ":" current_state() ":" next_state() <SEMICOLON>
}

void seq_input_list() :
{
}
{
	level_input_list() | edge_input_list()
}

void level_input_list() :
{
}
{
	level_symbol() ( level_symbol() )*
}

void edge_input_list() :
{
}
{
	( level_symbol() )* edge_indicator() ( level_symbol() )*
}

void edge_indicator() :
{
}
{
	"(" level_symbol() level_symbol() ")" | edge_symbol()
}

void current_state() :
{
}
{
	level_symbol()
}

void next_state() :
{
}
{
	output_symbol() | "-"
}

void output_symbol() :
{
}
{
	"0" | "1" | "x" | "X"
}

void level_symbol() :
{
}
{
	"0" | "1" | "x" | "X" | "?" | "b" | "B"
}
	
void edge_symbol() :
{
}
{
	"r" | "R" | "f" | "F" | "p" | "P" | "n" | "N" | "*"
}


/********************************************************************
 * A.5.4 UDP instantiation
 ********************************************************************/

void udp_instantiation() :
{
}
{
	udp_identifier() [ drive_strength() ] [ delay2() ] udp_instance() ( "," udp_instance() )* <SEMICOLON>
}

void udp_instance() :
{
}
{
	[ name_of_instance() ] "(" output_terminal() "," input_terminal() ( "," input_terminal() )* ")"
}

/****************************************************************************
 * A.6 Behavioral statements
 ****************************************************************************/

/********************************************************************
 * A.6.1 Continuous assignment and net alias statements
 ********************************************************************/
void continuous_assign() :
{
}
{
	<ASSIGN> [ drive_strength() ] [ delay3() ] list_of_net_assignments() <SEMICOLON>
	| <ASSIGN> [ delay_control() ] list_of_variable_assignments() <SEMICOLON>
}

void list_of_net_assignments() :
{
}
{
	net_assignment() ( "," net_assignment())*
}

void list_of_variable_assignments() :
{
}
{
	variable_assignment() ( "," variable_assignment())*
}

void net_alias() :
{
}
{
	<ALIAS> net_lvalue() "=" net_lvalue() ("=" net_lvalue())* <SEMICOLON>
}

void net_assignment() :
{
}
{
	net_lvalue() "=" expression()
}

/********************************************************************
 * A.6.2 Procedural blocks and assignments
 ********************************************************************/

void initial_construct() :
{
}
{
	<INITIAL> statement_or_null()
}

void always_construct() :
{
}
{
	always_keyword() statement()
}

void always_keyword() :
{
}
{
	<ALWAYS> | <ALWAYS_COMB> | <ALWAYS_LATCH> | <ALWAYS_FF>
}

void final_construct() :
{
}
{
	<FINAL> function_statement()
}

void blocking_assignment() :
{
}
{
	variable_lvalue() "=" delay_or_event_control() expression()
	| hierarchical_dynamic_array_variable_identifier() "=" dynamic_array_new()
	| [ implicit_class_handle() "." | class_scope() | package_scope() ] hierarchical_variable_identifier()
	select() "=" class_new()
	| operator_assignment()
}

void operator_assignment() :
{
}
{
	variable_lvalue() assignment_operator() expression()
}

void assignment_operator() :
{
}
{
	"=" | "+=" | "-=" | "*=" | "/=" | "%=" | "&=" | "|=" | "^=" | "<<=" | ">>=" | "<<<=" | ">>>="
}

void nonblocking_assignment() :
{
}
{
	variable_lvalue() "<=" [ delay_or_event_control() ] expression()
}

void procedural_continuous_assignment() :
{
}
{
	<ASSIGN> variable_assignment()
	| <DEASSIGN> variable_lvalue()
	| <FORCE> variable_assignment()
	| <FORCE> net_assignment()
	| <RELEASE> variable_lvalue()
	| <RELEASE> net_lvalue()
}

void variable_assignment() :
{
}
{
	variable_lvalue() "=" expression()
}

/********************************************************************
 * A.6.3 Parallel and sequential blocks
 ********************************************************************/
void action_block() :
{
}
{
	statement_or_null()
	| [ statement() ] <ELSE> statement_or_null()
}

void seq_block() :
{
}
{
	<BEGIN> [ ":" block_identifier() ] (block_item_declaration())* (statement_or_null())*
	<END> [ ":" block_identifier() ]
}

void par_block() :
{
}
{
	<FORK> [ ":" block_identifier() ] (block_item_declaration())* (statement_or_null())*
	join_keyword() [ ":" block_identifier() ]
}

void join_keyword() :
{
}
{
	<JOIN> | <JOIN_ANY> | <JOIN_NONE>
}

/********************************************************************
 * A.6.4 Statements
 ********************************************************************/
void statement_or_null() :
{
}
{
	statement()
	| (attribute_instance())* <SEMICOLON>
}

void statement() :
{
}
{
	[ block_identifier() ":" ] (attribute_instance())* statement_item()
}

void statement_item() :
{
}
{
	blocking_assignment() <SEMICOLON>
	| nonblocking_assignment() <SEMICOLON>
	| procedural_continuous_assignment() <SEMICOLON>
	| case_statement()
	| conditional_statement()
	| inc_or_dec_expression() <SEMICOLON>
	| subroutine_call_statement()
	| disable_statement()
	| event_trigger()
	| loop_statement()
	| jump_statement()
	| par_block()
	| procedural_timing_control_statement()
	| seq_block()
	| wait_statement()
	| procedural_assertion_statement()
	| clocking_drive() <SEMICOLON>
	| randsequence_statement()
	| randcase_statement()
	| expect_property_statement()
}

void function_statement() :
{
}
{
	statement()
}

void function_statement_or_null() :
{
}
{
	function_statement()
	| (attribute_instance())* <SEMICOLON>
}

void variable_identifier_list() :
{
}
{
	variable_identifier() ( "," variable_identifier())*
}

/********************************************************************
 * A.6.5 Timing control statements
 ********************************************************************/

void procedural_timing_control_statement() :
{
}
{
	procedural_timing_control() statement_or_null()
}

void delay_or_event_control() :
{
}
{
	delay_control()
	| event_control()
	| <REPEAT> "(" expression() ")" event_control()
}

void delay_control() :
{
}
{
	"#" delay_value()
	| "#" "(" mintypmax_expression() ")"
}

void event_control() :
{
}
{
	"@" hierarchical_event_identifier()
	| "@" "(" event_expression() ")"
	| "@*"
	| "@" "(" "*" ")"
	| "@" sequence_instance()
}

void event_expression() :
{
}
{
  (
	[ edge_identifier() ] expression() [ <IFF> expression() ]
	| sequence_instance() [ <IFF> expression() ]
  ) [event_expression_2()]
}

void event_expression_2() :
{
}
{
  (
	  <OR> event_expression()
	| "," event_expression()
  ) event_expression()
}

void procedural_timing_control() :
{
}
{
	delay_control()
	| event_control()
	| cycle_delay()
}

void jump_statement() :
{
}
{
	// CHG: expression can expand to "", so remove []
	<RETURN> expression() <SEMICOLON>
	| <BREAK> <SEMICOLON>
	| <CONTINUE> <SEMICOLON>
}

void wait_statement() :
{
}
{
	<WAIT> "(" expression() ")" statement_or_null()
	| <WAIT> <FORK> <SEMICOLON>
	| <WAIT_ORDER> "(" hierarchical_identifier() ( "," hierarchical_identifier())* ")" action_block()
}

void event_trigger() :
{
}
{
	"->" hierarchical_event_identifier() <SEMICOLON>
	| "->>" [ delay_or_event_control() ] hierarchical_event_identifier() <SEMICOLON>
}

void disable_statement() :
{
}
{
	<DISABLE> hierarchical_task_identifier() <SEMICOLON>
	| <DISABLE> hierarchical_block_identifier() <SEMICOLON>
	| <DISABLE> <FORK> <SEMICOLON>
}

/********************************************************************
 * A.6.6 Conditional statements
 ********************************************************************/
void conditional_statement() :
{
}
{
	<IF> "(" cond_predicate() ")" statement_or_null() [ <ELSE> statement_or_null() ]
	| unique_priority_if_statement()
}

void unique_priority_if_statement() :
{
}
{
	[ unique_priority() ] <IF> "(" cond_predicate() ")" statement_or_null()
	( <ELSE> <IF> "(" cond_predicate() ")" statement_or_null())*
	[ <ELSE> statement_or_null() ]
}

void unique_priority() :
{
}
{
	<UNIQUE> | <PRIORITY>
}

void cond_predicate() :
{
}
{
	expression_or_cond_pattern() ( "&&&" expression_or_cond_pattern())*
}

void expression_or_cond_pattern() :
{
}
{
	expression() | cond_pattern()
}

void cond_pattern() :
{
}
{
	expression() <MATCHES> pattern()
}

/********************************************************************
 * A.6.7 case statements
 ********************************************************************/

void case_statement() :
{
}
{
	[ unique_priority() ] case_keyword() "(" expression() ")" case_item() ( case_item())* <ENDCASE>
	| [ unique_priority() ] case_keyword() "(" expression() ")" <MATCHES> case_pattern_item() ( case_pattern_item())* <ENDCASE>
	| [ unique_priority() ] <CASE> "(" expression() ")" <INSIDE> case_inside_item() ( case_inside_item())* <ENDCASE>
}

void case_keyword() :
{
}
{
	<CASE> | <CASEZ> | <CASEX>
}

void case_item() :
{
}
{
	expression() ( "," expression())* ":" statement_or_null()
	| <T_DEFAULT> [ ":" ] statement_or_null()
}

void case_pattern_item() :
{
}
{
	pattern() [ "&&&" expression() ] ":" statement_or_null()
	| <T_DEFAULT> [ ":" ] statement_or_null()
}

void case_inside_item() :
{
}
{
	open_range_list() ":" statement_or_null()
	| <T_DEFAULT> [ ":" ] statement_or_null()
}

void randcase_statement() :
{
}
{
	<RANDCASE> randcase_item() ( randcase_item())* <ENDCASE>
}

void randcase_item() :
{
}
{
	expression() ":" statement_or_null()
}

/********************************************************************
 * A.6.7.1 Patterns
 ********************************************************************/ 
void pattern() :
{
}
{
	"." variable_identifier()
	| ".*"
	| constant_expression()
	// CHG: pattern can expand to "", so remove []
	| <TAGGED> member_identifier() pattern()
	| "’{" pattern() ("," pattern())* "}"
	| "’{" member_identifier() ":" pattern() ( "," member_identifier() ":" pattern())* "}"
}

void assignment_pattern() :
{
}
{
	"'{" expression() ( "," expression())* "}"
	| "'{" structure_pattern_key() ":" expression() ( "," structure_pattern_key() ":" expression())* "}"
	| "'{" array_pattern_key() ":" expression() ( "," array_pattern_key() ":" expression())* "}"
	| "'{" constant_expression() "{" expression() ( "," expression() )* "}" "}"
}

	
void structure_pattern_key() :
{
}
{
	member_identifier() | assignment_pattern_key()
}
	
void array_pattern_key() :
{
}
{
	constant_expression() | assignment_pattern_key()
}
	
void assignment_pattern_key() :
{
}
{
	simple_type() | <T_DEFAULT>
}
	
void assignment_pattern_expression() :
{
}
{
	[ assignment_pattern_expression_type() ] assignment_pattern()
}

void assignment_pattern_expression_type() :
{
}
{
	ps_type_identifier() | ps_parameter_identifier() | integer_atom_type()
}
	
void constant_assignment_pattern_expression() :
{
}
{
	assignment_pattern_expression()
}

void assignment_pattern_net_lvalue() :
{
}
{
	"'{" net_lvalue() ( "," net_lvalue())* "}"
}

void assignment_pattern_variable_lvalue() :
{
}
{
	"'{" variable_lvalue() ( "," variable_lvalue())* "}"
}

/********************************************************************
 * A.6.8 Looping statements  
 ********************************************************************/
void loop_statement() :
{
}
{
	<FOREVER> statement_or_null()
	| <REPEAT> "(" expression() ")" statement_or_null()
	| <WHILE> "(" expression() ")" statement_or_null()
	| <FOR> "(" for_initialization() <SEMICOLON> expression() <SEMICOLON> for_step() ")"
		statement_or_null()
	| <DO> statement_or_null() <WHILE> "(" expression() ")" <SEMICOLON>
	| <FOREACH> "(" array_identifier() "[" loop_variables() "]" ")" statement()
}

void for_initialization() :
{
}
{
	list_of_variable_assignments()
	| for_variable_declaration() ( "," for_variable_declaration())*
}

void for_variable_declaration() :
{
}
{
	data_type() variable_identifier() "=" expression()
		( "," variable_identifier() "=" expression())*
}

void for_step() :
{
}
{
	for_step_assignment() ( "," for_step_assignment() )*
}

void for_step_assignment() :
{
}
{
	operator_assignment()
	| inc_or_dec_expression()
	| function_subroutine_call()
}

void loop_variables() :
{
}
{
	"[" index_variable_identifier() "]" ( "," "[" index_variable_identifier() "]")*
}

/********************************************************************
 * A.6.9 Subroutine call statements  
 ********************************************************************/

void subroutine_call_statement() :
{
}
{
	subroutine_call() <SEMICOLON>
	| <VOID> "'" "(" function_subroutine_call() ")" <SEMICOLON>
}

/********************************************************************
 * A.6.10 Assertion statements  
 ********************************************************************/

void procedural_assertion_statement() :
{
}
{
	concurrent_assertion_statement()
	| immediate_assert_statement()
}

void immediate_assert_statement() :
{
}
{
	<ASSERT> "(" expression() ")" action_block()
}

/********************************************************************
 * A.6.11 Clocking block  
 ********************************************************************/

void clocking_declaration() :
{
}
{
	[ <T_DEFAULT> ] <CLOCKING> [ clocking_identifier() ] clocking_event() <SEMICOLON>
	( clocking_item() )*
	<ENDCLOCKING> [ ":" clocking_identifier() ]
}

void clocking_event() :
{
}
{
	"@" identifier()
	| "@" "(" event_expression() ")"
}

void clocking_item() :
{
}
{
	<T_DEFAULT> default_skew() <SEMICOLON>
	| clocking_direction() list_of_clocking_decl_assign() <SEMICOLON>
	| ( attribute_instance() )* concurrent_assertion_item_declaration()
}

void default_skew() :
{
}
{
	<INPUT> clocking_skew()
	| <OUTPUT> clocking_skew()
	| <INPUT> clocking_skew() <OUTPUT> clocking_skew()
}

void clocking_direction() :
{
}
{
	<INPUT> [ clocking_skew() ]
	| <OUTPUT> [ clocking_skew() ]
	| <INPUT> [ clocking_skew() ] <OUTPUT> [ clocking_skew() ]
	| <INOUT>
}

void list_of_clocking_decl_assign() :
{
}
{
	clocking_decl_assign() ( "," clocking_decl_assign() )*
}

void clocking_decl_assign() :
{
}
{
	signal_identifier() [ "=" expression() ]
}

void clocking_skew() :
{
}
{
	edge_identifier() [ delay_control() ]
	| delay_control()
}

void clocking_drive() :
{
}
{
	clockvar_expression() "<=" [ cycle_delay() ] expression()
	| cycle_delay() clockvar_expression() "<=" expression()
}

void cycle_delay() :
{
}
{
	"##" integral_number()
	| "##" identifier()
	| "##" "(" expression() ")"
}

void clockvar() :
{
}
{
	hierarchical_identifier()
}

void clockvar_expression() :
{
}
{
	clockvar() select()
}

/****************************************************************************
 * A.6.12 Randsequence
 ****************************************************************************/

void randsequence_statement() :
{
}
{
	<RANDSEQUENCE> "(" [ production_identifier() ] ")"
	production() ( production() )*
	<ENDSEQUENCE>
}

void production() :
{
}
{
	[ function_data_type() ] production_identifier() [ "(" tf_port_list() ")" ] ":" rs_rule() ( "|" rs_rule() )* <SEMICOLON>
}

void rs_rule() :
{
}
{
	rs_production_list() [ ":=" weight_specification() [ rs_code_block() ] ]
}

void rs_production_list() :
{
}
{
	rs_prod() ( rs_prod() )*
	| <RAND> <JOIN> [ "(" expression() ")" ] production_item() production_item() ( production_item() )*
}

void weight_specification() :
{
}
{
	integral_number()
	| ps_identifier()
	| "(" expression() ")"
}

void rs_code_block() :
{
}
{
	"{" ( data_declaration() )* ( statement_or_null() )* "}"
}

void rs_prod() :
{
}
{
	production_item()
	| rs_code_block()
	| rs_if_else()
	| rs_repeat()
	| rs_case()
}

void production_item() :
{
}
{
	production_identifier() [ "(" list_of_arguments() ")" ]
}

void rs_if_else() :
{
}
{
	<IF> "(" expression() ")" production_item() [ <ELSE> production_item() ]
}

void rs_repeat() :
{
}
{
	<REPEAT> "(" expression() ")" production_item()
}

void rs_case() :
{
}
{
	<CASE> "(" expression() ")" rs_case_item() ( rs_case_item() )* <ENDCASE>
}

void rs_case_item() :
{
}
{
	expression() ( "," expression() )* ":" production_item() <SEMICOLON>
	| <T_DEFAULT> [ ":" ] production_item() <SEMICOLON>
}

/****************************************************************************
 * A.7 Specify section
 ****************************************************************************/

/********************************************************************
 * A.7.1 Specify block declaration
 ********************************************************************/

void specify_block() :
{
}
{
	<SPECIFY> ( specify_item() )* <ENDSPECIFY>
}

void specify_item() :
{
}
{
	specparam_declaration()
	| pulsestyle_declaration()
	| showcancelled_declaration()
	| path_declaration()
	
	// FIXME:
	/*
	| system_timing_check()
	 */
}

void pulsestyle_declaration() :
{
}
{
	<PULSESTYLE_ONEVENT> list_of_path_outputs() <SEMICOLON>
	| <PULSESTYLE_ONDETECT> list_of_path_outputs() <SEMICOLON>
}

void showcancelled_declaration() :
{
}
{
	<SHOWCANCELLED> list_of_path_outputs() <SEMICOLON>
	| <NOSHOWCANCELLED> list_of_path_outputs() <SEMICOLON>
}

/********************************************************************
 * A.7.2 Specify path declarations
 ********************************************************************/

void path_declaration() :
{
}
{
	simple_path_declaration() <SEMICOLON>
	| edge_sensitive_path_declaration() <SEMICOLON>
	| state_dependent_path_declaration() <SEMICOLON>
}

void simple_path_declaration() :
{
}
{
	parallel_path_description() "=" path_delay_value()
	| full_path_description() "=" path_delay_value()
}

void parallel_path_description() :
{
}
{
	"(" specify_input_terminal_descriptor() [ polarity_operator() ] "=>" specify_output_terminal_descriptor() ")"
}

void full_path_description() :
{
}
{
	"(" list_of_path_inputs() [ polarity_operator() ] "*>" list_of_path_outputs() ")"
}

void list_of_path_inputs() :
{
}
{
	specify_input_terminal_descriptor() ( "," specify_input_terminal_descriptor() )*
}

void list_of_path_outputs() :
{
}
{
	specify_output_terminal_descriptor() ( "," specify_output_terminal_descriptor() )*
}

/********************************************************************
 * A.7.3 Specify block terminals
 ********************************************************************/

void specify_input_terminal_descriptor() :
{
}
{
	input_identifier() [ "[" constant_range_expression() "]" ]
}

void specify_output_terminal_descriptor() :
{
}
{
	output_identifier() [ "[" constant_range_expression() "]" ]
}

void input_identifier() :
{
}
{
	input_port_identifier() | inout_port_identifier() | interface_identifier() "." port_identifier()
}

void output_identifier() :
{
}
{
	output_port_identifier() | inout_port_identifier() | interface_identifier() "." port_identifier()
}

/********************************************************************
 * A.7.4 Specify path delays
 ********************************************************************/

void path_delay_value() :
{
}
{
	list_of_path_delay_expressions()
	| "(" list_of_path_delay_expressions() ")"
}

void list_of_path_delay_expressions() :
{
}
{
	t_path_delay_expression()
	| trise_path_delay_expression() "," tfall_path_delay_expression()
	| trise_path_delay_expression() "," tfall_path_delay_expression() "," tz_path_delay_expression()
	| t01_path_delay_expression() "," t10_path_delay_expression() "," t0z_path_delay_expression() ","
		tz1_path_delay_expression() "," t1z_path_delay_expression() "," tz0_path_delay_expression()
	| t01_path_delay_expression() "," t10_path_delay_expression() "," t0z_path_delay_expression() ","
		tz1_path_delay_expression() "," t1z_path_delay_expression() "," tz0_path_delay_expression() ","
		t0x_path_delay_expression() "," tx1_path_delay_expression() "," t1x_path_delay_expression() ","
		tx0_path_delay_expression() "," txz_path_delay_expression() "," tzx_path_delay_expression()
}

void t_path_delay_expression() :
{
}
{
	path_delay_expression()
}

void trise_path_delay_expression() :
{
}
{
	path_delay_expression()
}

void tfall_path_delay_expression() :
{
}
{
	path_delay_expression()
}

void tz_path_delay_expression() :
{
}
{
	path_delay_expression()
}

void t01_path_delay_expression() :
{
}
{
	path_delay_expression()
}

void t10_path_delay_expression() :
{
}
{
	path_delay_expression()
}

void t0z_path_delay_expression() :
{
}
{
	path_delay_expression()
}

void tz1_path_delay_expression() :
{
}
{
	path_delay_expression()
}

void t1z_path_delay_expression() :
{
}
{
	path_delay_expression()
}

void tz0_path_delay_expression() :
{
}
{
	path_delay_expression()
}

void t0x_path_delay_expression() :
{
}
{
	path_delay_expression()
}

void tx1_path_delay_expression() :
{
}
{
	path_delay_expression()
}

void t1x_path_delay_expression() :
{
}
{
	path_delay_expression()
}

void tx0_path_delay_expression() :
{
}
{
	path_delay_expression()
}

void txz_path_delay_expression() :
{
}
{
	path_delay_expression()
}

void tzx_path_delay_expression() :
{
}
{
	path_delay_expression()
}

void path_delay_expression() :
{
}
{
	constant_mintypmax_expression()
}

void edge_sensitive_path_declaration() :
{
}
{
	parallel_edge_sensitive_path_description() "=" path_delay_value()
	| full_edge_sensitive_path_description() "=" path_delay_value()
}

void parallel_edge_sensitive_path_description() :
{
}
{
	"(" [ edge_identifier() ] specify_input_terminal_descriptor() "=>"
		"(" specify_output_terminal_descriptor() [ polarity_operator() ] ":" data_source_expression() ")" ")"
}

void full_edge_sensitive_path_description() :
{
}
{
	"(" [ edge_identifier() ] list_of_path_inputs() "*>"
		"(" list_of_path_outputs() [ polarity_operator() ] ":" data_source_expression() ")" ")"
}

void data_source_expression() :
{
}
{
	expression()
}

void edge_identifier() :
{
}
{
	<POSEDGE> | <NEGEDGE>
}

void state_dependent_path_declaration() :
{
}
{
	<IF> "(" module_path_expression() ")" simple_path_declaration()
	| <IF> "(" module_path_expression() ")" edge_sensitive_path_declaration()
	| <IFNONE> simple_path_declaration()
}

void polarity_operator() :
{
}
{
	"+" | "-"
}

/*
A.7.5 System timing checks
A.7.5.1 System timing check commands
system_timing_check ::=
$setup_timing_check
| $hold_timing_check
| $setuphold_timing_check
| $recovery_timing_check
| $removal_timing_check
| $recrem_timing_check
| $skew_timing_check
| $timeskew_timing_check
| $fullskew_timing_check
| $period_timing_check
| $width_timing_check
| $nochange_timing_check
$setup_timing_check ::=
$setup ( data_event , reference_event , timing_check_limit [ , [ notifier ] ] ) ;
$hold_timing_check ::=
$hold ( reference_event , data_event , timing_check_limit [ , [ notifier ] ] ) ;
$setuphold_timing_check ::=
$setuphold ( reference_event , data_event , timing_check_limit , timing_check_limit
[ , [ notifier ] [ , [ stamptime_condition ] [ , [ checktime_condition ]
[ , [ delayed_reference ] [ , [ delayed_data ] ] ] ] ] ] ) ;
$recovery_timing_check ::=
$recovery ( reference_event , data_event , timing_check_limit [ , [ notifier ] ] ) ;
$removal_timing_check ::=
$removal ( reference_event , data_event , timing_check_limit [ , [ notifier ] ] ) ;
$recrem_timing_check ::=
$recrem ( reference_event , data_event , timing_check_limit , timing_check_limit
[ , [ notifier ] [ , [ stamptime_condition ] [ , [ checktime_condition ]
[ , [ delayed_reference ] [ , [ delayed_data ] ] ] ] ] ] ) ;
$skew_timing_check ::=
$skew ( reference_event , data_event , timing_check_limit [ , [ notifier ] ] ) ;
$timeskew_timing_check ::=
$timeskew ( reference_event , data_event , timing_check_limit
[ , [ notifier ] [ , [ event_based_flag ] [ , [ remain_active_flag ] ] ] ] ) ;
$fullskew_timing_check ::=
$fullskew ( reference_event , data_event , timing_check_limit , timing_check_limit
[ , [ notifier ] [ , [ event_based_flag ] [ , [ remain_active_flag ] ] ] ] ) ;
$period_timing_check ::=
$period ( controlled_reference_event , timing_check_limit [ , [ notifier ] ] ) ;
$width_timing_check ::=
$width ( controlled_reference_event , timing_check_limit , threshold [ , [ notifier ] ] ) ;
$nochange_timing_check ::=
$nochange ( reference_event , data_event , start_edge_offset ,
end_edge_offset [ , [ notifier ] ] ) ;
A.7.5.2 System timing check command arguments
checktime_condition ::= mintypmax_expression
controlled_reference_event ::= controlled_timing_check_event
data_event ::= timing_check_event
delayed_data ::=
terminal_identifier
| terminal_identifier [ constant_mintypmax_expression ]
delayed_reference ::=
terminal_identifier
| terminal_identifier [ constant_mintypmax_expression ]
end_edge_offset ::= mintypmax_expression
event_based_flag ::= constant_expression
notifier ::= variable_identifier
reference_event ::= timing_check_event
remain_active_flag ::= constant_mintypmax_expression
stamptime_condition ::= mintypmax_expression
start_edge_offset ::= mintypmax_expression
threshold ::=constant_expression
timing_check_limit ::= expression
A.7.5.3 System timing check event definitions
timing_check_event ::=
[timing_check_event_control] specify_terminal_descriptor [ &&& timing_check_condition ]
controlled_timing_check_event ::=
timing_check_event_control specify_terminal_descriptor [ &&& timing_check_condition ]
timing_check_event_control ::=
posedge
| negedge
| edge_control_specifier
specify_terminal_descriptor ::=
specify_input_terminal_descriptor
| specify_output_terminal_descriptor
edge_control_specifier ::= edge [ edge_descriptor { , edge_descriptor } ]
edge_descriptor1 ::= 01 | 10 | z_or_x zero_or_one | zero_or_one z_or_x
zero_or_one ::= 0 | 1
z_or_x ::= x | X | z | Z
timing_check_condition ::=
scalar_timing_check_condition
| ( scalar_timing_check_condition )
scalar_timing_check_condition ::=
expression
| ~ expression
| expression == scalar_constant
| expression === scalar_constant
| expression != scalar_constant
| expression !== scalar_constant
scalar_constant ::= 1’b0 | 1’b1 | 1’B0 | 1’B1 | ’b0 | ’b1 | ’B0 | ’B1 | 1 | 0
*/

/****************************************************************************
 * A.8 Expressions
 ****************************************************************************/

/********************************************************************
 * A.8.1 Concatenations  
 ********************************************************************/

void concatenation() :
{
}
{
	"{" expression() ( "," expression() )* "}"
}

void constant_concatenation() :
{
}
{
	"{" constant_expression() ( "," constant_expression() )* "}"
}

void constant_multiple_concatenation() :
{
}
{
	"{" constant_expression() constant_concatenation() "}"
}

void module_path_concatenation() :
{
}
{
	"{" module_path_expression() ( "," module_path_expression() )* "}"
}

void module_path_multiple_concatenation() :
{
}
{
	"{" constant_expression() module_path_concatenation() "}"
}

void multiple_concatenation() :
{
}
{
	"{" expression() concatenation() "}"
}

void streaming_concatenation() :
{
}
{
	// CHG: slice_size() can expand to "", so remove []
	"{" stream_operator() slice_size() stream_concatenation() "}"
}

void stream_operator() :
{
}
{
	">>" | "<<"
}

void slice_size() :
{
}
{
	simple_type() | constant_expression()
}

void stream_concatenation() :
{
}
{
	"{" stream_expression() ( "," stream_expression() )* "}"
}

void stream_expression() :
{
}
{
	expression() [ <WITH> "[" array_range_expression() "]" ]
}

void array_range_expression() :
{
}
{
	expression()
	| expression() ":" expression()
	| expression() "+:" expression()
	| expression() "-:" expression()
}

void empty_queue() :
{
}
{
	"{" "}"
}

/********************************************************************
 * A.8.2 Subroutine calls  
 ********************************************************************/

void constant_function_call() :
{
}
{
	function_subroutine_call()
}

void tf_call() :
{
}
{
	ps_or_hierarchical_tf_identifier() (attribute_instance())* [ "(" list_of_arguments() ")" ]
}

void system_tf_call() :
{
}
{
	system_tf_identifier() [ "(" list_of_arguments() ")" ]
	| system_tf_identifier() "(" data_type() [ "," expression() ] ")"
}

void subroutine_call() :
{
}
{
	tf_call()
	| system_tf_call()
	| method_call()
	| randomize_call()
}

void function_subroutine_call() :
{
}
{
	subroutine_call()
}

void list_of_arguments() :
{
}
{
	// CHG: expression() can expand to "", so remove []
	expression() ("," expression() )* ( "," "." identifier() "(" expression() ")" )*
	// CHG: expression() can expand to "", so remove []
	| "." identifier() "(" expression() ")" ( "," "." identifier() "(" expression() ")")*
}

void method_call() :
{
}
{
	method_call_root() "." method_call_body()
}

void method_call_body() :
{
}
{
	method_identifier() (attribute_instance())* [ "(" list_of_arguments() ")" ]
	| built_in_method_call()
}

void built_in_method_call() :
{
}
{
	array_manipulation_call()
	| randomize_call()
}

void array_manipulation_call() :
{
}
{
	array_method_name() (attribute_instance())*
	[ "(" list_of_arguments() ")" ]
	[ <WITH> "(" expression() ")" ]
}

void randomize_call() :
{
}
{
	<RANDOMIZE> (attribute_instance())*
	[ "(" [ variable_identifier_list() | <NULL> ] ")" ]
	[ <WITH> constraint_block() ]
}

void method_call_root() :
{
}
{
	expression() | implicit_class_handle()
}

void array_method_name() :
{
}
{
	method_identifier() | <UNIQUE> | <AND> | <OR> | <XOR>
}

/********************************************************************
 * A.8.3 Expressions  
 ********************************************************************/
void inc_or_dec_expression() :
{
}
{
	inc_or_dec_operator() (attribute_instance())* variable_lvalue()
	| variable_lvalue() (attribute_instance())* inc_or_dec_operator()
}

void conditional_expression() :
{
}
{
	/* FIXME: introduce parens to eliminate left recursion 
	cond_predicate() "?" (attribute_instance())* expression() ":" expression()
	 */
	"(" cond_predicate() ")" "?" (attribute_instance())* expression() ":" expression()
}

void constant_expression() :
{
}
{
	/* CHG: Remove left recursion
	constant_primary()
	| unary_operator() (attribute_instance())* constant_primary()
	| constant_expression() binary_operator() (attribute_instance())* constant_expression()
	| constant_expression() "?" (attribute_instance())* constant_expression() ":" constant_expression()
	 */
	(
		constant_primary()
		| unary_operator() (attribute_instance())* constant_primary()
	) [constant_expression_2()]
}

void constant_expression_2() :
{
}
{
	(
		  binary_operator() (attribute_instance())* constant_expression()
		| "?" (attribute_instance())* constant_expression() ":" constant_expression()
	) constant_expression()
}


void constant_mintypmax_expression() :
{
}
{
	constant_expression()
	| constant_expression() ":" constant_expression() ":" constant_expression()
}

void constant_param_expression() :
{
}
{
	constant_mintypmax_expression() | data_type() | "$"
}

void param_expression() :
{
}
{
	mintypmax_expression() | data_type()
}

void constant_range_expression() :
{
}
{
	constant_expression()
	| constant_part_select_range()
}

void constant_part_select_range() :
{
}
{
	constant_range()
	| constant_indexed_range()
}

void constant_range() :
{
}
{
	constant_expression() ":" constant_expression()

}

void constant_indexed_range() :
{
}
{
	constant_expression() "+:" constant_expression()
	| constant_expression() "-:" constant_expression()
}

void expression() :
{
}
{
	/* CHG: eliminate left recursion
	primary()
	| unary_operator() (attribute_instance())* primary()
	| inc_or_dec_expression()
	| "(" operator_assignment() ")"
	| expression() binary_operator() (attribute_instance())* expression()
	| conditional_expression()
	| inside_expression()
	| tagged_union_expression()
	 */
  (
	primary()
	| unary_operator() (attribute_instance())* primary()
	| inc_or_dec_expression()
	| "(" operator_assignment() ")"
	| conditional_expression()
	// CHG: bring inside_expression() literal up
	// | inside_expression()
	
	| tagged_union_expression()
  ) [expression_2()]
}

void expression_2() :
{
}
{
  (
	binary_operator() (attribute_instance())* expression() 
	<INSIDE> "{" open_range_list() "}"
  ) expression_2()
}

void tagged_union_expression() :
{
}
{
	// CHG: expression() can expand to "", so remove []
	<TAGGED> member_identifier() expression()
}

void inside_expression() :
{
}
{
	expression() <INSIDE> "{" open_range_list() "}"
}

void value_range() :
{
}
{
	expression()
	| "[" expression() ":" expression() "]"
}

void mintypmax_expression() :
{
}
{
	expression()
	| expression() ":" expression() ":" expression()
}

/* CHG: refactor into module_path_expression() to help
 *      eliminate left recursion
void module_path_conditional_expression() :
{
}
{
	module_path_expression() "?" (attribute_instance())*
	module_path_expression() ":" module_path_expression()
}
 */

void module_path_expression() :
{
}
{
  /* CHG: remove left recursion
	module_path_primary()
	| unary_module_path_operator() (attribute_instance())* module_path_primary()
	| module_path_expression() binary_module_path_operator() (attribute_instance())* module_path_expression()
	| module_path_conditional_expression()
   */

  (
	module_path_primary()
	| unary_module_path_operator() (attribute_instance())* module_path_primary()
  ) [module_path_expression_2()]
}

void module_path_expression_2() :
{
}
{
  (
	"?" (attribute_instance())*
	  module_path_expression() ":" module_path_expression()  
	binary_module_path_operator() (attribute_instance())* module_path_expression()
  ) module_path_expression()
}

void module_path_mintypmax_expression() :
{
}
{
	module_path_expression()
	| module_path_expression() ":" module_path_expression() ":" module_path_expression()
}

void part_select_range() :
{
}
{
	constant_range() | indexed_range()
}

void indexed_range() :
{
}
{
	expression() "+:" constant_expression()
	| expression() "-:" constant_expression()
}

void genvar_expression() :
{
}
{
	constant_expression()
}

/********************************************************************
 * A.8.4 Primaries  
 ********************************************************************/
void constant_primary() :
{
}
{
	primary_literal()
	| ps_parameter_identifier() constant_select()
	// CHG: constant_range_expression() can expand to "", so remove []
	| specparam_identifier() constant_range_expression()
	| genvar_identifier()
	| [ package_scope() | class_scope() ] enum_identifier()
	| constant_concatenation()
	| constant_multiple_concatenation()
	| constant_function_call()
	| "(" constant_mintypmax_expression() ")"
	| constant_cast()
	| constant_assignment_pattern_expression()
	| type_reference()
}

void module_path_primary() :
{
}
{
	number()
	| identifier()
	| module_path_concatenation()
	| module_path_multiple_concatenation()
	| function_subroutine_call()
	| "(" module_path_mintypmax_expression() ")"
}

void primary() :
{
}
{
	primary_literal()
	| [ implicit_class_handle() "." | class_scope() | package_scope() ] hierarchical_identifier() select()
	| empty_queue()
	| concatenation()
	| multiple_concatenation()
	// FIXME: workaround to eliminate left recursion -- just for now
	| "(" function_subroutine_call() ")"
	| "(" mintypmax_expression() ")"
	| cast()
	| assignment_pattern_expression()
	| streaming_concatenation()
	| sequence_method_call()
	| <THIS>
	| "$"
	| <NULL>
}

void time_literal() :
{
}
{
	unsigned_number() time_unit()
	| fixed_point_number() time_unit()
}

void time_unit() :
{
}
{
	"s" | "ms" | "us" | "ns" | "ps" | "fs" | "step"
}

void implicit_class_handle() :
{
}
{
	<THIS> | <SUPER> | <THIS> "." <SUPER>
}

void bit_select() :
{
}
{
	( "[" expression() "]" )*
}

void select() :
{
}
{
	[ ( "." member_identifier() bit_select())* "." member_identifier() ] bit_select() [ "[" part_select_range() "]" ]
}

void constant_bit_select() :
{
}
{
	( "[" constant_expression() "]")*
}

void constant_select() :
{
}
{
	[ ( "." member_identifier() constant_bit_select())* "." member_identifier() ] constant_bit_select()
	[ "[" constant_part_select_range() "]" ]
}

void primary_literal() :
{
}
{
	number() | time_literal() | unbased_unsized_literal() | string_literal()
}

void constant_cast() :
{
}
{
	casting_type() "'" "(" constant_expression() ")"
}

void cast() :
{
}
{
	casting_type() "'" "(" expression() ")"
}

/********************************************************************
 * A.8.5 Expression left-side values  
 ********************************************************************/

void net_lvalue() :
{
}
{
	ps_or_hierarchical_net_identifier() constant_select()
	| "{" net_lvalue() ( "," net_lvalue() )* "}"
	| [ assignment_pattern_expression_type() ] assignment_pattern_net_lvalue()
}

void variable_lvalue() :
{
}
{
	[ implicit_class_handle() "." | package_scope() ] hierarchical_variable_identifier() select()
	| "{" variable_lvalue() ( "," variable_lvalue() )* "}"
	| [ assignment_pattern_expression_type() ] assignment_pattern_variable_lvalue()
	| streaming_concatenation()
}

/********************************************************************
 * A.8.6 Operators  
 ********************************************************************/

void unary_operator() :
{
}
{
	"+" | "-" | "!" | "~" | "&" | "~&" | "|" | "~|" | "^" | "~^" | "^~"
}

void binary_operator() :
{
}
{
	"+" | "-" | "*" | "/" | "%" | "==" | "!=" | "===" | "!==" | "==?" | "!=?" | "&&" | "||" | "**"
	| "<" | "<=" | ">" | ">=" | "&" | "|" | "^" | "^~" | "~^" | ">>" | "<<" | ">>>" | "<<<"
}

void inc_or_dec_operator() :
{
}
{
	"++" | "--"
}

void unary_module_path_operator() :
{
}
{
	"!" | "~" | "&" | "~&" | "|" | "~|" | "^" | "~^" | "^~"
}

void binary_module_path_operator() :
{
}
{
	"==" | "!=" | "&&" | "||" | "&" | "|" | "^" | "^~" | "~^"
}

/********************************************************************
 * A.8.7 Numbers  
 ********************************************************************/
void number() :
{
}
{
	integral_number()
	| real_number()
}

void integral_number() :
{
}
{
	decimal_number()
	| octal_number()
	| binary_number()
	| hex_number()
}

void decimal_number() :
{
}
{
	unsigned_number()
	| [ size() ] decimal_base() unsigned_number()
	| [ size() ] decimal_base() x_digit() ( "_" )*
	| [ size() ] decimal_base() z_digit() ( "_" )*
}

void binary_number() :
{
}
{
	[ size() ] binary_base() binary_value()
}

void octal_number() :
{
}
{
	[ size() ] octal_base() octal_value()
}

void hex_number() :
{
}
{
	[ size() ] hex_base() hex_value()
}

void sign() :
{
}
{
	"+" | "-"
}

void size() :
{
}
{
	non_zero_unsigned_number()
}

void non_zero_unsigned_number() :
{
}
{
	non_zero_decimal_digit() ( "_" | decimal_digit())*
}

void real_number() :
{
}
{
	fixed_point_number()
	| unsigned_number() [ "." unsigned_number() ] exp() [ sign() ] unsigned_number()
}

void fixed_point_number() :
{
}
{
	unsigned_number() "." unsigned_number()
}

void exp() :
{
}
{
	"e" | "E"
}

void unsigned_number() :
{
}
{
	decimal_digit() ( "_" | decimal_digit())*
}

void binary_value() :
{
}
{
	binary_digit() ( "_" | binary_digit())*
}

void octal_value() :
{
}
{
	octal_digit() ( "_" | octal_digit())*
}

void hex_value() :
{
}
{
	hex_digit() ( "_" | hex_digit())*
}

void decimal_base() :
{
}
{
	"’" ["s"|"S"] "d" | "’" ["s"|"S"]"D"
}

void binary_base() :
{
}
{
	"’" ["s"|"S"]"b" | "’"["s"|"S"]"B"
}

void octal_base() :
{
}
{
	"’" ["s"|"S"]"o" | "’" ["s"|"S"]"O"
}

void hex_base() :
{
}
{
	"’" ["s"|"S"]"h" | "’" ["s"|"S"]"H"
}

void non_zero_decimal_digit() :
{
}
{
//	1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9
	<NZ_DEC_DIGIT>
}

void decimal_digit() :
{
}
{
//	0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9
	<DEC_DIGIT>
}

void binary_digit() :
{
}
{
	x_digit() | z_digit() | "0" | "1"
}

void octal_digit() :
{
}
{
//	x_digit | z_digit | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7
	x_digit() | z_digit() | <OCT_DIGIT>
}

void hex_digit() :
{
}
{
	x_digit() | z_digit() | <HEX_DIGIT> 
}

void x_digit() :
{
}
{
	"x" | "X"
}

void z_digit() :
{
}
{
	"z" | "Z" | "?"
}

void unbased_unsized_literal() :
{
}
{
	"'0" | "'1" | "'" (z_digit() | x_digit())
}

/********************************************************************
 * A.8.8 Strings  
 ********************************************************************/

Token string_literal() :
{
	Token tok = null; // FIXME:
}
{
	// TODO: 
//	"\"" { Any_ASCII_Characters } \"""
	
	{return tok;}
}

/********************************************************************
 *  
 ********************************************************************/

/****************************************************************************
 * A.9 General
 ****************************************************************************/

/****************************************************************************
 * A.9.1 Attributes
 ****************************************************************************/
void attribute_instance() :
{
}
{
	<ATTR_START> attr_spec() ( "," attr_spec())*  <ATTR_END>
}

void attr_spec() :
{
}
{
	attr_name() [ "=" constant_expression() ]
}

void attr_name() :
{
}
{
	identifier()
}

/****************************************************************************
 * A.9.2 Comments
 ****************************************************************************/


/****************************************************************************
 * A.9.3 Identifiers
 ****************************************************************************/
void array_identifier() :
{
}
{
	identifier()
}

void block_identifier() :
{
}
{
	identifier()
}

void bin_identifier() :
{
}
{
	identifier()
}

Token c_identifier() :
{
	Token tok;
}
{
	( tok = <C_IDENT>)
	
	{return tok;}
}

Token cell_identifier() :
{
	Token tok;
}
{
	(tok = identifier())
	{return tok;}
}

Token class_identifier() :
{
	Token tok;
}
{
	(tok = identifier())
	{return tok;}
}

Token class_variable_identifier() :
{
	Token tok;
}
{
	(tok = variable_identifier())
	{return tok;}
}

Token clocking_identifier() :
{
	Token tok;
}
{
	(tok = identifier())
	{return tok;}
}

Token config_identifier() :
{
	Token tok;
}
{
	(tok = identifier())
	{return tok;}
}

Token const_identifier() :
{
	Token tok;
}
{
	(tok = identifier())
	{return tok;}
}

Token constraint_identifier() :
{
	Token tok;
}
{
	(tok = identifier())
	{return tok;}
}

Token covergroup_identifier() :
{
	Token tok;
}
{
	(tok = identifier())
	{return tok;}
}

Token covergroup_variable_identifier() :
{
	Token tok;
}
{
	(tok = variable_identifier())
	{return tok;}
}

Token cover_point_identifier() :
{
	Token tok;
}
{
	(tok = identifier())
	{return tok;}
}

Token dynamic_array_variable_identifier() :
{
	Token tok;
}
{
	(tok = variable_identifier())
	{return tok;}
}

Token enum_identifier() :
{
	Token tok;
}
{
	(tok = identifier())
	{return tok;}
}

Token escaped_identifier() :
{
	Token tok;
}
{
	(<ESCAPE> {tok = skipToSpace();})
	{return tok;}
}

JAVACODE
Token skipToSpace()
{
    Token current = token;
    Token token ;
    int lastColumn=-1;
    StringBuffer image = new StringBuffer();

    for(;;) 
    { 
    	    token = getToken(1);
            
            if (token.kind == EOF)
                    unexpectedEof(current);
            //if there was a break
            if (token.beginColumn != lastColumn+1 && lastColumn!=-1)
            {
                    break ;
            }
            lastColumn=token.endColumn;

            image.append(token.image);
            getNextToken();
    }
    token.image = image.toString();
    return token ;
}

JAVACODE
void unexpectedEof(Token token)
{
	throw new RuntimeException("unexpected EOF");
	/*
	ParseException ex = new ParseException("unexpected EOF");
	ex.currentToken = token;
	throw ex;
	 */
}


Token formal_identifier() :
{
	Token tok;
}
{
	(tok = identifier())
	{return tok;}
}

Token function_identifier() :
{
	Token tok;
}
{
	(tok = identifier())
	{return tok;}
}

Token generate_block_identifier() :
{
	Token tok;
}
{
	(tok = identifier())
	{return tok;}
}

Token genvar_identifier() :
{
	Token tok;
}
{
	(tok = identifier())
	{return tok;}
}

Token hierarchical_block_identifier() :
{
	Token tok;
}
{
	(tok  = hierarchical_identifier())
	{return tok;}
}

Token hierarchical_dynamic_array_variable_identifier() :
{
	Token tok;
}
{
	(tok  = hierarchical_variable_identifier())
	{return tok;}
}

Token hierarchical_event_identifier() :
{
	Token tok;
}
{
	(tok = hierarchical_identifier())
	{return tok;}
}

Token hierarchical_identifier() :
{
	Token tok = null;
}
{
	// TODO: figure out how to concat these together
	[ "$root" "." ] ( identifier() constant_bit_select() "." )* identifier()
	{return tok;}
}

Token hierarchical_net_identifier() :
{
	Token tok;
}
{
	(tok = hierarchical_identifier())
	{return tok;}
}

Token hierarchical_parameter_identifier() :
{
	Token tok;
}
{
	(tok = hierarchical_identifier())
	{return tok;}
}

Token hierarchical_task_identifier() :
{
	Token tok;
}
{
	(tok = hierarchical_identifier())
	{return tok;}
}

Token hierarchical_tf_identifier() :
{
	Token tok;
}
{
	(tok = hierarchical_identifier())
	{return tok;}
}

Token hierarchical_variable_identifier() :
{
	Token tok;
}
{
	(tok = hierarchical_identifier())
	{return tok; }
}

Token identifier() :
{
	Token tok;
}
{
	(tok = simple_identifier() | tok = escaped_identifier())
	{
		return tok;
	}
}

Token index_variable_identifier() :
{
	Token tok;
}
{
	(tok = identifier())
	{return tok;}
}

Token interface_identifier() :
{
	Token tok;
}
{
	(tok = identifier())
	{return tok;}
}

Token interface_instance_identifier() :
{
	Token tok;
}
{
	(tok = identifier())
	{return tok;}
}

Token inout_port_identifier() :
{
	Token tok;
}
{
	(tok = identifier())
	{return tok;}
}

Token input_port_identifier() :
{
	Token tok;
}
{
	(tok = identifier())
	{return tok;}
}

Token instance_identifier() :
{
	Token tok;
}
{
	(tok = identifier())
	{return tok;}
}

Token library_identifier() :
{
	Token tok;
}
{
	(tok = identifier())
	{return tok;}
}

Token member_identifier() :
{
	Token tok;
}
{
	(tok = identifier())
	{return tok;}
}

Token method_identifier() :
{
	Token tok;
}
{
	(tok = identifier())
	{return tok;}
}

Token modport_identifier() :
{
	Token tok;
}
{
	(tok = identifier())
	{return tok;}
}

Token module_identifier() :
{
	Token tok;
}
{
	(tok = identifier())
	{return tok;}
}

Token net_identifier() :
{
	Token tok;
}
{
	(tok = identifier())
	{return tok;}
}

Token output_port_identifier() :
{
	Token tok;
}
{
	(tok = identifier())
	{return tok;}
}

Token package_identifier() :
{
	Token tok;
}
{
	(tok = identifier())
	{return tok;}
}

void package_scope() :
{
}
{
	package_identifier() "::"
	| "$unit" "::"
}

Token parameter_identifier() :
{
	Token tok;
}
{
	(tok = identifier())
	{return tok;}
}

Token port_identifier() :
{
	Token tok;
}
{
	(tok = identifier())
	{return tok;}
}

Token production_identifier() :
{
	Token tok;
}
{
	(tok = identifier())
	{return tok;}
}

Token program_identifier() :
{
	Token tok;
}
{
	(tok = identifier())
	{return tok;}
}

Token property_identifier() :
{
	Token tok;
}
{
	(tok = identifier())
	{return tok;}
}

void ps_class_identifier() :
{
}
{
	[ package_scope() ] class_identifier()
}

void ps_covergroup_identifier() :
{
}
{
	[ package_scope() ] covergroup_identifier()
}

void ps_identifier() :
{
}
{
	[ package_scope() ] identifier()
}

void ps_or_hierarchical_net_identifier() :
{
}
{
	[ package_scope() ] net_identifier() | hierarchical_net_identifier()
}

void ps_or_hierarchical_tf_identifier() :
{
}
{
	[ package_scope() ] tf_identifier() | hierarchical_tf_identifier()
}

void ps_parameter_identifier() :
{
}
{
	[ package_scope() ] parameter_identifier()
	| ( generate_block_identifier() [ "[" constant_expression() "]" ] "." )* parameter_identifier()
}

void ps_property_identifier() :
{
}
{
	[ package_scope() ] property_identifier()
}

void ps_sequence_identifier() :
{
}
{
	[ package_scope() ] sequence_identifier()
}

void ps_type_identifier() :
{
}
{
	[ package_scope() ] type_identifier()
}

Token sequence_identifier() :
{
	Token tok;
}
{
	(tok = identifier())
	{return tok;}
}

Token signal_identifier() :
{
	Token tok;
}
{
	(tok = identifier())
	{return tok;}
}

Token simple_identifier() :
{
	Token tok;
}
{
	(tok = <S_IDENT> | tok = <C_IDENT>)
	{return tok;}
}

Token specparam_identifier() :
{
	Token tok;
}
{
	(tok = identifier())
	{return tok;}
}

Token system_tf_identifier() :
{
	Token tok;
}
{
	(tok = <TF_IDENT>)
	{return tok;}
}


Token task_identifier() :
{
	Token tok;
}
{
	(tok = identifier())
	{return tok;}
}

Token tf_identifier() :
{
	Token tok;
}
{
	(tok = identifier())
	{return tok;}
}

Token terminal_identifier() :
{
	Token tok;
}
{
	(tok = identifier())
	{return tok;}
}

Token topmodule_identifier() :
{
	Token tok;
}
{
	(tok = identifier())
	{return tok;}
}

Token type_identifier() :
{
	Token tok;
}
{
	(tok = identifier())
	{return tok;}
}

Token udp_identifier() :
{
	Token tok;
}
{
	(tok = identifier())
	{return tok;}
}

Token variable_identifier() :
{
	Token tok;
}
{
	(tok = identifier())
	{return tok;}
}


